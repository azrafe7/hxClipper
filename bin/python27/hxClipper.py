# Generated by Haxe 4.2.0
# coding: utf-8
from __future__ import division
from __future__ import absolute_import
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import functools as python_lib_Functools
import traceback as python_lib_Traceback
from itertools import imap
from itertools import ifilter


class _hx_AnonObject(object):
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError(u'field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum(object):
    _hx_class_name = u"Enum"
    __slots__ = (u"tag", u"index", u"params")
    _hx_fields = [u"tag", u"index", u"params"]
    _hx_methods = [u"__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + u'(' + (u', '.join(unicode(v) for v in self.params)) + u')'



class Class(object): pass


class Reflect(object):
    _hx_class_name = u"Reflect"
    __slots__ = ()
    _hx_statics = [u"field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std(object):
    _hx_class_name = u"Std"
    __slots__ = ()
    _hx_statics = [u"isOfType", u"string"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException, _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == unicode):
            return isinstance(v,unicode)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_class_name")) and (not hasattr(v,u"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException, _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,u"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,u"")


class Float(object): pass


class Int(object): pass


class Bool(object): pass


class Dynamic(object): pass


class haxe_Exception(Exception):
    _hx_class_name = u"haxe.Exception"
    __slots__ = (u"_hx___nativeStack", u"_hx___skipStack", u"_hx___nativeException", u"_hx___previousException")
    _hx_fields = [u"__nativeStack", u"__skipStack", u"__nativeException", u"__previousException"]
    _hx_methods = [u"unwrap", u"get_native"]
    _hx_statics = [u"caught", u"thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super(haxe_Exception, self).__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(unicode(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e



class haxe_NativeStackTrace(object):
    _hx_class_name = u"haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = [u"saveStack", u"exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = u"haxe.ValueException"
    __slots__ = (u"value",)
    _hx_fields = [u"value"]
    _hx_methods = [u"unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super(haxe_ValueException, self).__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_ds_ArraySort(object):
    _hx_class_name = u"haxe.ds.ArraySort"
    __slots__ = ()
    _hx_statics = [u"sort", u"rec", u"doMerge", u"rotate", u"gcd", u"upper", u"lower", u"swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g = (_hx_from + 1)
            _g1 = to
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)


class haxe_iterators_ArrayIterator(object):
    _hx_class_name = u"haxe.iterators.ArrayIterator"
    __slots__ = (u"array", u"current")
    _hx_fields = [u"array", u"current"]
    _hx_methods = [u"hasNext", u"next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class haxe_iterators_ArrayKeyValueIterator(object):
    _hx_class_name = u"haxe.iterators.ArrayKeyValueIterator"
    __slots__ = (u"current", u"array")
    _hx_fields = [u"current", u"array"]
    _hx_methods = [u"hasNext", u"next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({u'value': python_internal_ArrayImpl._get(self.array, self.current), u'key': _hx_local_2()})
        return _hx_local_3()



class DoublePoint(object):
    _hx_class_name = u"DoublePoint"
    __slots__ = (u"x", u"y")
    _hx_fields = [u"x", u"y"]
    _hx_methods = [u"clone", u"__repr__"]
    _hx_statics = [u"fromDoublePoint", u"fromIntPoint"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def clone(self):
        return DoublePoint(self.x,self.y)

    def __repr__(self):
        return ((((u"(x:" + Std.string(self.x)) + u", y:") + Std.string(self.y)) + u")")

    @staticmethod
    def fromDoublePoint(dp):
        return dp.clone()

    @staticmethod
    def fromIntPoint(ip):
        return DoublePoint(ip.x,ip.y)



class PolyNode(object):
    _hx_class_name = u"PolyNode"
    __slots__ = (u"mParent", u"mPolygon", u"mIndex", u"mJoinType", u"mEndtype", u"mChildren", u"parent", u"isOpen")
    _hx_fields = [u"mParent", u"mPolygon", u"mIndex", u"mJoinType", u"mEndtype", u"mChildren", u"isOpen"]
    _hx_methods = [u"isHoleNode", u"get_numChildren", u"get_contour", u"addChild", u"getNext", u"getNextSiblingUp", u"get_children", u"get_parent", u"get_isHole"]

    def __init__(self):
        self.isOpen = None
        self.parent = None
        self.mEndtype = None
        self.mJoinType = None
        self.mIndex = None
        self.mParent = None
        self.mChildren = list()
        self.mPolygon = list()

    def isHoleNode(self):
        result = True
        node = self.mParent
        while (node is not None):
            result = (not result)
            node = node.mParent
        return result

    def get_numChildren(self):
        return len(self.mChildren)

    def get_contour(self):
        return self.mPolygon

    def addChild(self,child):
        cnt = len(self.mChildren)
        _this = self.mChildren
        _this.append(child)
        child.mParent = self
        child.mIndex = cnt

    def getNext(self):
        if (len(self.mChildren) > 0):
            return (self.mChildren[0] if 0 < len(self.mChildren) else None)
        else:
            return self.getNextSiblingUp()

    def getNextSiblingUp(self):
        if (self.mParent is None):
            return None
        elif (self.mIndex == ((len(self.mParent.mChildren) - 1))):
            return self.mParent.getNextSiblingUp()
        else:
            return python_internal_ArrayImpl._get(self.mParent.mChildren, (self.mIndex + 1))

    def get_children(self):
        return self.mChildren

    def get_parent(self):
        return self.mParent

    def get_isHole(self):
        return self.isHoleNode()



class PolyTree(PolyNode):
    _hx_class_name = u"PolyTree"
    __slots__ = (u"mAllPolys",)
    _hx_fields = [u"mAllPolys"]
    _hx_methods = [u"clear", u"getFirst", u"get_total"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = PolyNode


    def __init__(self):
        self.mAllPolys = list()
        super(PolyTree, self).__init__()

    def clear(self):
        _g = 0
        _g1 = len(self.mAllPolys)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.mAllPolys, i, None)
        array = self.mAllPolys
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        array = self.mChildren
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]

    def getFirst(self):
        if (len(self.mChildren) > 0):
            return (self.mChildren[0] if 0 < len(self.mChildren) else None)
        else:
            return None

    def get_total(self):
        result = len(self.mAllPolys)
        if ((result > 0) and (((self.mChildren[0] if 0 < len(self.mChildren) else None) != (self.mAllPolys[0] if 0 < len(self.mAllPolys) else None)))):
            result = (result - 1)
        return result



class IntPoint(object):
    _hx_class_name = u"IntPoint"
    __slots__ = (u"x", u"y", u"z")
    _hx_fields = [u"x", u"y", u"z"]
    _hx_methods = [u"clone", u"copyFrom", u"__repr__", u"equals"]
    _hx_statics = [u"fromFloats", u"fromDoublePoint", u"fromIntPoint"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (z is None):
            z = 0
        self.x = x
        self.y = y
        self.z = z

    def clone(self):
        return IntPoint(self.x,self.y,self.z)

    def copyFrom(self,ip):
        self.x = ip.x
        self.y = ip.y
        self.z = ip.z

    def __repr__(self):
        return ((((((u"(x:" + Std.string(self.x)) + u", y:") + Std.string(self.y)) + u", z:") + Std.string(self.z)) + u")")

    def equals(self,ip):
        if (self.x == ip.x):
            return (self.y == ip.y)
        else:
            return False

    @staticmethod
    def fromFloats(x,y,z = None):
        if (z is None):
            z = 0
        tmp = None
        try:
            tmp = int(x)
        except BaseException, _g:
            None
            tmp = None
        tmp1 = tmp
        tmp = None
        try:
            tmp = int(y)
        except BaseException, _g:
            None
            tmp = None
        tmp2 = tmp
        tmp = None
        try:
            tmp = int(z)
        except BaseException, _g:
            None
            tmp = None
        return IntPoint(tmp1,tmp2,tmp)

    @staticmethod
    def fromDoublePoint(dp):
        return IntPoint.fromFloats(dp.x,dp.y,0)

    @staticmethod
    def fromIntPoint(pt):
        return pt.clone()



class IntRect(object):
    _hx_class_name = u"IntRect"
    __slots__ = (u"left", u"top", u"right", u"bottom")
    _hx_fields = [u"left", u"top", u"right", u"bottom"]
    _hx_methods = [u"clone"]

    def __init__(self,l,t,r,b):
        self.left = l
        self.top = t
        self.right = r
        self.bottom = b

    def clone(self,ir):
        return IntRect(self.left,self.top,self.right,self.bottom)


class ClipType(Enum):
    __slots__ = ()
    _hx_class_name = u"ClipType"
    _hx_constructs = [u"CT_INTERSECTION", u"CT_UNION", u"CT_DIFFERENCE", u"CT_XOR"]
ClipType.CT_INTERSECTION = ClipType(u"CT_INTERSECTION", 0, ())
ClipType.CT_UNION = ClipType(u"CT_UNION", 1, ())
ClipType.CT_DIFFERENCE = ClipType(u"CT_DIFFERENCE", 2, ())
ClipType.CT_XOR = ClipType(u"CT_XOR", 3, ())

class PolyType(Enum):
    __slots__ = ()
    _hx_class_name = u"PolyType"
    _hx_constructs = [u"PT_SUBJECT", u"PT_CLIP"]
PolyType.PT_SUBJECT = PolyType(u"PT_SUBJECT", 0, ())
PolyType.PT_CLIP = PolyType(u"PT_CLIP", 1, ())

class PolyFillType(Enum):
    __slots__ = ()
    _hx_class_name = u"PolyFillType"
    _hx_constructs = [u"PFT_EVEN_ODD", u"PFT_NON_ZERO", u"PFT_POSITIVE", u"PFT_NEGATIVE"]
PolyFillType.PFT_EVEN_ODD = PolyFillType(u"PFT_EVEN_ODD", 0, ())
PolyFillType.PFT_NON_ZERO = PolyFillType(u"PFT_NON_ZERO", 1, ())
PolyFillType.PFT_POSITIVE = PolyFillType(u"PFT_POSITIVE", 2, ())
PolyFillType.PFT_NEGATIVE = PolyFillType(u"PFT_NEGATIVE", 3, ())

class JoinType(Enum):
    __slots__ = ()
    _hx_class_name = u"JoinType"
    _hx_constructs = [u"JT_SQUARE", u"JT_ROUND", u"JT_MITER"]
JoinType.JT_SQUARE = JoinType(u"JT_SQUARE", 0, ())
JoinType.JT_ROUND = JoinType(u"JT_ROUND", 1, ())
JoinType.JT_MITER = JoinType(u"JT_MITER", 2, ())

class EndType(Enum):
    __slots__ = ()
    _hx_class_name = u"EndType"
    _hx_constructs = [u"ET_CLOSED_POLYGON", u"ET_CLOSED_LINE", u"ET_OPEN_BUTT", u"ET_OPEN_SQUARE", u"ET_OPEN_ROUND"]
EndType.ET_CLOSED_POLYGON = EndType(u"ET_CLOSED_POLYGON", 0, ())
EndType.ET_CLOSED_LINE = EndType(u"ET_CLOSED_LINE", 1, ())
EndType.ET_OPEN_BUTT = EndType(u"ET_OPEN_BUTT", 2, ())
EndType.ET_OPEN_SQUARE = EndType(u"ET_OPEN_SQUARE", 3, ())
EndType.ET_OPEN_ROUND = EndType(u"ET_OPEN_ROUND", 4, ())

class hxClipper__Clipper_EdgeSide(Enum):
    __slots__ = ()
    _hx_class_name = u"hxClipper._Clipper.EdgeSide"
    _hx_constructs = [u"ES_LEFT", u"ES_RIGHT"]
hxClipper__Clipper_EdgeSide.ES_LEFT = hxClipper__Clipper_EdgeSide(u"ES_LEFT", 0, ())
hxClipper__Clipper_EdgeSide.ES_RIGHT = hxClipper__Clipper_EdgeSide(u"ES_RIGHT", 1, ())

class hxClipper__Clipper_Direction(Enum):
    __slots__ = ()
    _hx_class_name = u"hxClipper._Clipper.Direction"
    _hx_constructs = [u"D_RIGHT_TO_LEFT", u"D_LEFT_TO_RIGHT"]
hxClipper__Clipper_Direction.D_RIGHT_TO_LEFT = hxClipper__Clipper_Direction(u"D_RIGHT_TO_LEFT", 0, ())
hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT = hxClipper__Clipper_Direction(u"D_LEFT_TO_RIGHT", 1, ())

class hxClipper__Clipper_NodeType(Enum):
    __slots__ = ()
    _hx_class_name = u"hxClipper._Clipper.NodeType"
    _hx_constructs = [u"NT_ANY", u"NT_OPEN", u"NT_CLOSED"]
hxClipper__Clipper_NodeType.NT_ANY = hxClipper__Clipper_NodeType(u"NT_ANY", 0, ())
hxClipper__Clipper_NodeType.NT_OPEN = hxClipper__Clipper_NodeType(u"NT_OPEN", 1, ())
hxClipper__Clipper_NodeType.NT_CLOSED = hxClipper__Clipper_NodeType(u"NT_CLOSED", 2, ())


class hxClipper__Clipper_TEdge(object):
    _hx_class_name = u"hxClipper._Clipper.TEdge"
    __slots__ = (u"bot", u"curr", u"top", u"delta", u"dx", u"polyType", u"side", u"windDelta", u"windCnt", u"windCnt2", u"outIdx", u"next", u"prev", u"nextInLML", u"nextInAEL", u"prevInAEL", u"nextInSEL", u"prevInSEL")
    _hx_fields = [u"bot", u"curr", u"top", u"delta", u"dx", u"polyType", u"side", u"windDelta", u"windCnt", u"windCnt2", u"outIdx", u"next", u"prev", u"nextInLML", u"nextInAEL", u"prevInAEL", u"nextInSEL", u"prevInSEL"]
    _hx_methods = [u"__repr__"]

    def __init__(self):
        self.prevInSEL = None
        self.nextInSEL = None
        self.prevInAEL = None
        self.nextInAEL = None
        self.nextInLML = None
        self.prev = None
        self.next = None
        self.outIdx = None
        self.windCnt2 = None
        self.windCnt = None
        self.windDelta = None
        self.side = None
        self.polyType = None
        self.dx = None
        self.delta = IntPoint()
        self.top = IntPoint()
        self.curr = IntPoint()
        self.bot = IntPoint()

    def __repr__(self):
        return ((((((((u"TE(curr:" + HxOverrides.stringOrNull(self.curr.__repr__())) + u", bot:") + HxOverrides.stringOrNull(self.bot.__repr__())) + u", top:") + HxOverrides.stringOrNull(self.top.__repr__())) + u", dx:") + Std.string(self.dx)) + u")")



class IntersectNode(object):
    _hx_class_name = u"IntersectNode"
    __slots__ = (u"edge1", u"edge2", u"pt")
    _hx_fields = [u"edge1", u"edge2", u"pt"]

    def __init__(self):
        self.edge2 = None
        self.edge1 = None
        self.pt = IntPoint()



class hxClipper__Clipper_LocalMinima(object):
    _hx_class_name = u"hxClipper._Clipper.LocalMinima"
    __slots__ = (u"y", u"leftBound", u"rightBound", u"next")
    _hx_fields = [u"y", u"leftBound", u"rightBound", u"next"]

    def __init__(self):
        self.next = None
        self.rightBound = None
        self.leftBound = None
        self.y = None



class hxClipper__Clipper_Scanbeam(object):
    _hx_class_name = u"hxClipper._Clipper.Scanbeam"
    __slots__ = (u"y", u"next")
    _hx_fields = [u"y", u"next"]

    def __init__(self):
        self.next = None
        self.y = None



class hxClipper__Clipper_Maxima(object):
    _hx_class_name = u"hxClipper._Clipper.Maxima"
    __slots__ = (u"x", u"next", u"prev")
    _hx_fields = [u"x", u"next", u"prev"]

    def __init__(self):
        self.prev = None
        self.next = None
        self.x = None



class hxClipper__Clipper_OutRec(object):
    _hx_class_name = u"hxClipper._Clipper.OutRec"
    __slots__ = (u"idx", u"isHole", u"isOpen", u"firstLeft", u"pts", u"bottomPt", u"polyNode")
    _hx_fields = [u"idx", u"isHole", u"isOpen", u"firstLeft", u"pts", u"bottomPt", u"polyNode"]

    def __init__(self):
        self.polyNode = None
        self.bottomPt = None
        self.pts = None
        self.firstLeft = None
        self.isOpen = None
        self.isHole = None
        self.idx = None



class hxClipper__Clipper_OutPt(object):
    _hx_class_name = u"hxClipper._Clipper.OutPt"
    __slots__ = (u"idx", u"pt", u"next", u"prev")
    _hx_fields = [u"idx", u"pt", u"next", u"prev"]

    def __init__(self):
        self.prev = None
        self.next = None
        self.idx = None
        self.pt = IntPoint()



class hxClipper__Clipper_Join(object):
    _hx_class_name = u"hxClipper._Clipper.Join"
    __slots__ = (u"outPt1", u"outPt2", u"offPt")
    _hx_fields = [u"outPt1", u"outPt2", u"offPt"]

    def __init__(self):
        self.outPt2 = None
        self.outPt1 = None
        self.offPt = IntPoint()



class hxClipper_ClipperBase(object):
    _hx_class_name = u"hxClipper.ClipperBase"
    __slots__ = (u"mMinimaList", u"mCurrentLM", u"mEdges", u"mScanbeam", u"mPolyOuts", u"mActiveEdges", u"mUseFullRange", u"mHasOpenPaths", u"preserveCollinear")
    _hx_fields = [u"mMinimaList", u"mCurrentLM", u"mEdges", u"mScanbeam", u"mPolyOuts", u"mActiveEdges", u"mUseFullRange", u"mHasOpenPaths", u"preserveCollinear"]
    _hx_methods = [u"pointIsVertex", u"pointOnLineSegment", u"pointOnPolygon", u"clear", u"disposeLocalMinimaList", u"rangeTest", u"initEdge", u"initEdge2", u"findNextLocMin", u"processBound", u"addPath", u"addPaths", u"pt2IsBetweenPt1AndPt3", u"removeEdge", u"setDx", u"insertLocalMinima", u"popLocalMinima", u"reverseHorizontal", u"reset", u"insertScanbeam", u"popScanbeam", u"localMinimaPending", u"createOutRec", u"disposeOutRec", u"updateEdgeIntoAEL", u"swapPositionsInAEL", u"deleteFromAEL"]
    _hx_statics = [u"HORIZONTAL", u"SKIP", u"UNASSIGNED", u"TOLERANCE", u"nearZero", u"LO_RANGE", u"HI_RANGE", u"isHorizontal", u"slopesEqual", u"slopesEqual3", u"slopesEqual4", u"getBounds"]

    def __init__(self):
        self.preserveCollinear = None
        self.mActiveEdges = None
        self.mPolyOuts = None
        self.mScanbeam = None
        self.mEdges = list()
        self.mMinimaList = None
        self.mCurrentLM = None
        self.mUseFullRange = False
        self.mHasOpenPaths = False

    def pointIsVertex(self,pt,pp):
        pp2 = pp
        while True:
            if pp2.pt.equals(pt):
                return True
            pp2 = pp2.next
            if (not ((pp2 != pp))):
                break
        return False

    def pointOnLineSegment(self,pt,linePt1,linePt2,useFullRange):
        if (not ((((pt.x == linePt1.x) and ((pt.y == linePt1.y))) or (((pt.x == linePt2.x) and ((pt.y == linePt2.y))))))):
            if (((pt.x > linePt1.x) == ((pt.x < linePt2.x))) and (((pt.y > linePt1.y) == ((pt.y < linePt2.y))))):
                return ((((pt.x - linePt1.x)) * ((linePt2.y - linePt1.y))) == ((((linePt2.x - linePt1.x)) * ((pt.y - linePt1.y)))))
            else:
                return False
        else:
            return True

    def pointOnPolygon(self,pt,pp,useFullRange):
        pp2 = pp
        while True:
            if self.pointOnLineSegment(pt,pp2.pt,pp2.next.pt,useFullRange):
                return True
            pp2 = pp2.next
            if (pp2 == pp):
                break
        return False

    def clear(self):
        self.disposeLocalMinimaList()
        _g = 0
        _g1 = len(self.mEdges)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = len((self.mEdges[i] if i >= 0 and i < len(self.mEdges) else None))
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                python_internal_ArrayImpl._set((self.mEdges[i] if i >= 0 and i < len(self.mEdges) else None), j, None)
            array = (self.mEdges[i] if i >= 0 and i < len(self.mEdges) else None)
            _hx_len = len(array)
            pos = 0
            if (pos < 0):
                pos = (len(array) + pos)
            if (pos < 0):
                pos = 0
            res = array[pos:(pos + _hx_len)]
            del array[pos:(pos + _hx_len)]
        array = self.mEdges
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        self.mUseFullRange = False
        self.mHasOpenPaths = False

    def disposeLocalMinimaList(self):
        while (self.mMinimaList is not None):
            tmpLm = self.mMinimaList.next
            self.mMinimaList = None
            self.mMinimaList = tmpLm
        self.mCurrentLM = None

    def rangeTest(self,pt,useFullRange):
        if useFullRange:
            if ((((pt.x > 32767) or ((pt.y > 32767))) or ((-pt.x > 32767))) or ((-pt.y > 32767))):
                raise haxe_Exception.thrown(ClipperException(u"Coordinate outside allowed range"))
        elif ((((pt.x > 32767) or ((pt.y > 32767))) or ((-pt.x > 32767))) or ((-pt.y > 32767))):
            useFullRange = True
            self.rangeTest(pt,useFullRange)
        return useFullRange

    def initEdge(self,e,eNext,ePrev,pt):
        e.next = eNext
        e.prev = ePrev
        e.curr.copyFrom(pt)
        e.outIdx = -1

    def initEdge2(self,e,polyType):
        if (e.curr.y >= e.next.curr.y):
            e.bot.copyFrom(e.curr)
            e.top.copyFrom(e.next.curr)
        else:
            e.top.copyFrom(e.curr)
            e.bot.copyFrom(e.next.curr)
        self.setDx(e)
        e.polyType = polyType

    def findNextLocMin(self,e):
        e2 = None
        while True:
            while ((not e.bot.equals(e.prev.bot)) or e.curr.equals(e.top)):
                e = e.next
            if ((e.dx != -3.4E+38) and ((e.prev.dx != -3.4E+38))):
                break
            while (e.prev.dx == -3.4E+38):
                e = e.prev
            e2 = e
            while (e.dx == -3.4E+38):
                e = e.next
            if (e.top.y == e.prev.bot.y):
                continue
            if (e2.prev.bot.x < e.bot.x):
                e = e2
            break
        return e

    def processBound(self,e,leftBoundIsForward):
        eStart = None
        result = e
        horz = None
        if (result.outIdx == -2):
            e = result
            if leftBoundIsForward:
                while (e.top.y == e.next.bot.y):
                    e = e.next
                while ((e != result) and ((e.dx == -3.4E+38))):
                    e = e.prev
            else:
                while (e.top.y == e.prev.bot.y):
                    e = e.prev
                while ((e != result) and ((e.dx == -3.4E+38))):
                    e = e.next
            if (e == result):
                if leftBoundIsForward:
                    result = e.next
                else:
                    result = e.prev
            else:
                if leftBoundIsForward:
                    e = result.next
                else:
                    e = result.prev
                locMin = hxClipper__Clipper_LocalMinima()
                locMin.next = None
                locMin.y = e.bot.y
                locMin.leftBound = None
                locMin.rightBound = e
                e.windDelta = 0
                result = self.processBound(e,leftBoundIsForward)
                self.insertLocalMinima(locMin)
            return result
        if (e.dx == -3.4E+38):
            if leftBoundIsForward:
                eStart = e.prev
            else:
                eStart = e.next
            if (eStart.dx == -3.4E+38):
                if ((eStart.bot.x != e.bot.x) and ((eStart.top.x != e.bot.x))):
                    self.reverseHorizontal(e)
            elif (eStart.bot.x != e.bot.x):
                self.reverseHorizontal(e)
        eStart = e
        if leftBoundIsForward:
            while ((result.top.y == result.next.bot.y) and ((result.next.outIdx != -2))):
                result = result.next
            if ((result.dx == -3.4E+38) and ((result.next.outIdx != -2))):
                horz = result
                while (horz.prev.dx == -3.4E+38):
                    horz = horz.prev
                if (horz.prev.top.x > result.next.top.x):
                    result = horz.prev
            while (e != result):
                e.nextInLML = e.next
                if (((e.dx == -3.4E+38) and ((e != eStart))) and ((e.bot.x != e.prev.top.x))):
                    self.reverseHorizontal(e)
                e = e.next
            if (((e.dx == -3.4E+38) and ((e != eStart))) and ((e.bot.x != e.prev.top.x))):
                self.reverseHorizontal(e)
            result = result.next
        else:
            while ((result.top.y == result.prev.bot.y) and ((result.prev.outIdx != -2))):
                result = result.prev
            if ((result.dx == -3.4E+38) and ((result.prev.outIdx != -2))):
                horz = result
                while (horz.next.dx == -3.4E+38):
                    horz = horz.next
                if ((horz.next.top.x == result.prev.top.x) or ((horz.next.top.x > result.prev.top.x))):
                    result = horz.next
            while (e != result):
                e.nextInLML = e.prev
                if (((e.dx == -3.4E+38) and ((e != eStart))) and ((e.bot.x != e.next.top.x))):
                    self.reverseHorizontal(e)
                e = e.prev
            if (((e.dx == -3.4E+38) and ((e != eStart))) and ((e.bot.x != e.next.top.x))):
                self.reverseHorizontal(e)
            result = result.prev
        return result

    def addPath(self,path,polyType,closed):
        if ((not closed) and ((polyType == PolyType.PT_CLIP))):
            raise haxe_Exception.thrown(ClipperException(u"AddPath: Open paths must be subject."))
        highI = (len(path) - 1)
        if closed:
            while ((highI > 0) and (path[highI] if highI >= 0 and highI < len(path) else None).equals((path[0] if 0 < len(path) else None))):
                highI = (highI - 1)
        while ((highI > 0) and (path[highI] if highI >= 0 and highI < len(path) else None).equals(python_internal_ArrayImpl._get(path, (highI - 1)))):
            highI = (highI - 1)
        if ((closed and ((highI < 2))) or (((not closed) and ((highI < 1))))):
            return False
        edges = list()
        _g = 0
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = hxClipper__Clipper_TEdge()
            edges.append(x)
        isFlat = True
        (edges[1] if 1 < len(edges) else None).curr.copyFrom((path[1] if 1 < len(path) else None))
        self.mUseFullRange = self.rangeTest((path[0] if 0 < len(path) else None),self.mUseFullRange)
        self.mUseFullRange = self.rangeTest((path[highI] if highI >= 0 and highI < len(path) else None),self.mUseFullRange)
        self.initEdge((edges[0] if 0 < len(edges) else None),(edges[1] if 1 < len(edges) else None),(edges[highI] if highI >= 0 and highI < len(edges) else None),(path[0] if 0 < len(path) else None))
        self.initEdge((edges[highI] if highI >= 0 and highI < len(edges) else None),(edges[0] if 0 < len(edges) else None),python_internal_ArrayImpl._get(edges, (highI - 1)),(path[highI] if highI >= 0 and highI < len(path) else None))
        i = (highI - 1)
        while (i >= 1):
            self.mUseFullRange = self.rangeTest((path[i] if i >= 0 and i < len(path) else None),self.mUseFullRange)
            self.initEdge((edges[i] if i >= 0 and i < len(edges) else None),python_internal_ArrayImpl._get(edges, (i + 1)),python_internal_ArrayImpl._get(edges, (i - 1)),(path[i] if i >= 0 and i < len(path) else None))
            i = (i - 1)
        eStart = (edges[0] if 0 < len(edges) else None)
        e = eStart
        eLoopStop = eStart
        while True:
            if (e.curr.equals(e.next.curr) and ((closed or ((e.next != eStart))))):
                if (e == e.next):
                    break
                if (e == eStart):
                    eStart = e.next
                e = self.removeEdge(e)
                eLoopStop = e
                continue
            if (e.prev == e.next):
                break
            elif ((closed and hxClipper_ClipperBase.slopesEqual3(e.prev.curr,e.curr,e.next.curr,self.mUseFullRange)) and (((not self.preserveCollinear) or (not self.pt2IsBetweenPt1AndPt3(e.prev.curr,e.curr,e.next.curr))))):
                if (e == eStart):
                    eStart = e.next
                e = self.removeEdge(e)
                e = e.prev
                eLoopStop = e
                continue
            e = e.next
            if ((e == eLoopStop) or (((not closed) and ((e.next == eStart))))):
                break
        if (((not closed) and ((e == e.next))) or ((closed and ((e.prev == e.next))))):
            return False
        if (not closed):
            self.mHasOpenPaths = True
            eStart.prev.outIdx = -2
        e = eStart
        while True:
            self.initEdge2(e,polyType)
            e = e.next
            if (isFlat and ((e.curr.y != eStart.curr.y))):
                isFlat = False
            if (not ((e != eStart))):
                break
        if isFlat:
            if closed:
                return False
            e.prev.outIdx = -2
            locMin = hxClipper__Clipper_LocalMinima()
            locMin.next = None
            locMin.y = e.bot.y
            locMin.leftBound = None
            locMin.rightBound = e
            locMin.rightBound.side = hxClipper__Clipper_EdgeSide.ES_RIGHT
            locMin.rightBound.windDelta = 0
            while True:
                if (e.bot.x != e.prev.top.x):
                    self.reverseHorizontal(e)
                if (e.next.outIdx == -2):
                    break
                e.nextInLML = e.next
                e = e.next
            self.insertLocalMinima(locMin)
            _this = self.mEdges
            _this.append(edges)
            return True
        _this = self.mEdges
        _this.append(edges)
        leftBoundIsForward = None
        eMin = None
        if e.prev.bot.equals(e.prev.top):
            e = e.next
        while True:
            e = self.findNextLocMin(e)
            if (e == eMin):
                break
            elif (eMin is None):
                eMin = e
            locMin = hxClipper__Clipper_LocalMinima()
            locMin.next = None
            locMin.y = e.bot.y
            if (e.dx < e.prev.dx):
                locMin.leftBound = e.prev
                locMin.rightBound = e
                leftBoundIsForward = False
            else:
                locMin.leftBound = e
                locMin.rightBound = e.prev
                leftBoundIsForward = True
            locMin.leftBound.side = hxClipper__Clipper_EdgeSide.ES_LEFT
            locMin.rightBound.side = hxClipper__Clipper_EdgeSide.ES_RIGHT
            if (not closed):
                locMin.leftBound.windDelta = 0
            elif (locMin.leftBound.next == locMin.rightBound):
                locMin.leftBound.windDelta = -1
            else:
                locMin.leftBound.windDelta = 1
            locMin.rightBound.windDelta = -locMin.leftBound.windDelta
            e = self.processBound(locMin.leftBound,leftBoundIsForward)
            if (e.outIdx == -2):
                e = self.processBound(e,leftBoundIsForward)
            E2 = self.processBound(locMin.rightBound,(not leftBoundIsForward))
            if (E2.outIdx == -2):
                E2 = self.processBound(E2,(not leftBoundIsForward))
            if (locMin.leftBound.outIdx == -2):
                locMin.leftBound = None
            elif (locMin.rightBound.outIdx == -2):
                locMin.rightBound = None
            self.insertLocalMinima(locMin)
            if (not leftBoundIsForward):
                e = E2
        return True

    def addPaths(self,paths,polyType,closed):
        result = False
        _g = 0
        _g1 = len(paths)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if self.addPath((paths[i] if i >= 0 and i < len(paths) else None),polyType,closed):
                result = True
        return result

    def pt2IsBetweenPt1AndPt3(self,pt1,pt2,pt3):
        if ((pt1.equals(pt3) or pt1.equals(pt2)) or pt3.equals(pt2)):
            return False
        elif (pt1.x != pt3.x):
            return ((pt2.x > pt1.x) == ((pt2.x < pt3.x)))
        else:
            return ((pt2.y > pt1.y) == ((pt2.y < pt3.y)))

    def removeEdge(self,e):
        e.prev.next = e.next
        e.next.prev = e.prev
        result = e.next
        e.prev = None
        return result

    def setDx(self,e):
        e.delta.x = (e.top.x - e.bot.x)
        e.delta.y = (e.top.y - e.bot.y)
        if (e.delta.y == 0):
            e.dx = -3.4E+38
        else:
            deltaX = e.delta.x
            e.dx = (deltaX / e.delta.y)

    def insertLocalMinima(self,newLm):
        if (self.mMinimaList is None):
            self.mMinimaList = newLm
        elif (newLm.y >= self.mMinimaList.y):
            newLm.next = self.mMinimaList
            self.mMinimaList = newLm
        else:
            tmpLm = self.mMinimaList
            while ((tmpLm.next is not None) and ((newLm.y < tmpLm.next.y))):
                tmpLm = tmpLm.next
            newLm.next = tmpLm.next
            tmpLm.next = newLm

    def popLocalMinima(self,y,current):
        current.lm = self.mCurrentLM
        if ((self.mCurrentLM is not None) and ((self.mCurrentLM.y == y))):
            self.mCurrentLM = self.mCurrentLM.next
            return True
        return False

    def reverseHorizontal(self,e):
        tmp = e.top.x
        e.top.x = e.bot.x
        e.bot.x = tmp
        tmp = e.top.z
        e.top.z = e.bot.z
        e.bot.z = tmp

    def reset(self):
        self.mCurrentLM = self.mMinimaList
        if (self.mCurrentLM is None):
            return
        self.mScanbeam = None
        lm = self.mMinimaList
        while (lm is not None):
            self.insertScanbeam(lm.y)
            e = lm.leftBound
            if (e is not None):
                e.curr.copyFrom(e.bot)
                e.outIdx = -1
            e = lm.rightBound
            if (e is not None):
                e.curr.copyFrom(e.bot)
                e.outIdx = -1
            lm = lm.next
        self.mActiveEdges = None

    def insertScanbeam(self,y):
        if (self.mScanbeam is None):
            self.mScanbeam = hxClipper__Clipper_Scanbeam()
            self.mScanbeam.next = None
            self.mScanbeam.y = y
        elif (y > self.mScanbeam.y):
            newSb = hxClipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = self.mScanbeam
            self.mScanbeam = newSb
        else:
            sb2 = self.mScanbeam
            while ((sb2.next is not None) and ((y <= sb2.next.y))):
                sb2 = sb2.next
            if (y == sb2.y):
                return
            newSb = hxClipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = sb2.next
            sb2.next = newSb

    def popScanbeam(self):
        res = _hx_AnonObject({u'y': 0, u'popped': False})
        if (self.mScanbeam is None):
            return res
        res.y = self.mScanbeam.y
        self.mScanbeam = self.mScanbeam.next
        res.popped = True
        return res

    def localMinimaPending(self):
        return (self.mCurrentLM is not None)

    def createOutRec(self):
        result = hxClipper__Clipper_OutRec()
        result.idx = -1
        result.isHole = False
        result.isOpen = False
        result.firstLeft = None
        result.pts = None
        result.bottomPt = None
        result.polyNode = None
        _this = self.mPolyOuts
        _this.append(result)
        result.idx = (len(self.mPolyOuts) - 1)
        return result

    def disposeOutRec(self,index):
        outRec = (self.mPolyOuts[index] if index >= 0 and index < len(self.mPolyOuts) else None)
        outRec.pts = None
        outRec = None
        python_internal_ArrayImpl._set(self.mPolyOuts, index, None)

    def updateEdgeIntoAEL(self,e):
        if (e.nextInLML is None):
            raise haxe_Exception.thrown(ClipperException(u"UpdateEdgeIntoAEL: invalid call"))
        aelPrev = e.prevInAEL
        aelNext = e.nextInAEL
        e.nextInLML.outIdx = e.outIdx
        if (aelPrev is not None):
            aelPrev.nextInAEL = e.nextInLML
        else:
            self.mActiveEdges = e.nextInLML
        if (aelNext is not None):
            aelNext.prevInAEL = e.nextInLML
        e.nextInLML.side = e.side
        e.nextInLML.windDelta = e.windDelta
        e.nextInLML.windCnt = e.windCnt
        e.nextInLML.windCnt2 = e.windCnt2
        e = e.nextInLML
        e.curr.copyFrom(e.bot)
        e.prevInAEL = aelPrev
        e.nextInAEL = aelNext
        if (not hxClipper_ClipperBase.isHorizontal(e)):
            self.insertScanbeam(e.top.y)
        return e

    def swapPositionsInAEL(self,edge1,edge2):
        if ((edge1.nextInAEL == edge1.prevInAEL) or ((edge2.nextInAEL == edge2.prevInAEL))):
            return
        if (edge1.nextInAEL == edge2):
            next = edge2.nextInAEL
            if (next is not None):
                next.prevInAEL = edge1
            prev = edge1.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge2
            edge2.prevInAEL = prev
            edge2.nextInAEL = edge1
            edge1.prevInAEL = edge2
            edge1.nextInAEL = next
        elif (edge2.nextInAEL == edge1):
            next = edge1.nextInAEL
            if (next is not None):
                next.prevInAEL = edge2
            prev = edge2.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge1
            edge1.prevInAEL = prev
            edge1.nextInAEL = edge2
            edge2.prevInAEL = edge1
            edge2.nextInAEL = next
        else:
            next = edge1.nextInAEL
            prev = edge1.prevInAEL
            edge1.nextInAEL = edge2.nextInAEL
            if (edge1.nextInAEL is not None):
                edge1.nextInAEL.prevInAEL = edge1
            edge1.prevInAEL = edge2.prevInAEL
            if (edge1.prevInAEL is not None):
                edge1.prevInAEL.nextInAEL = edge1
            edge2.nextInAEL = next
            if (edge2.nextInAEL is not None):
                edge2.nextInAEL.prevInAEL = edge2
            edge2.prevInAEL = prev
            if (edge2.prevInAEL is not None):
                edge2.prevInAEL.nextInAEL = edge2
        if (edge1.prevInAEL is None):
            self.mActiveEdges = edge1
        elif (edge2.prevInAEL is None):
            self.mActiveEdges = edge2

    def deleteFromAEL(self,e):
        aelPrev = e.prevInAEL
        aelNext = e.nextInAEL
        if (((aelPrev is None) and ((aelNext is None))) and ((e != self.mActiveEdges))):
            return
        if (aelPrev is not None):
            aelPrev.nextInAEL = aelNext
        else:
            self.mActiveEdges = aelNext
        if (aelNext is not None):
            aelNext.prevInAEL = aelPrev
        e.nextInAEL = None
        e.prevInAEL = None

    @staticmethod
    def nearZero(val):
        if (val > -1e-020):
            return (val < 1.0E-20)
        else:
            return False

    @staticmethod
    def isHorizontal(e):
        return (e.delta.y == 0)

    @staticmethod
    def slopesEqual(e1,e2,useFullRange):
        return ((e1.delta.y * e2.delta.x) == ((e1.delta.x * e2.delta.y)))

    @staticmethod
    def slopesEqual3(pt1,pt2,pt3,useFullRange):
        return (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) == 0)

    @staticmethod
    def slopesEqual4(pt1,pt2,pt3,pt4,useFullRange):
        return (((((pt1.y - pt2.y)) * ((pt3.x - pt4.x))) - ((((pt1.x - pt2.x)) * ((pt3.y - pt4.y))))) == 0)

    @staticmethod
    def getBounds(paths):
        i = 0
        cnt = len(paths)
        while ((i < cnt) and ((len((paths[i] if i >= 0 and i < len(paths) else None)) == 0))):
            i = (i + 1)
        if (i == cnt):
            return IntRect(0,0,0,0)
        result = IntRect(0,0,0,0)
        result.left = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), 0).x
        result.right = result.left
        result.top = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), 0).y
        result.bottom = result.top
        while (i < cnt):
            _g = 0
            _g1 = len((paths[i] if i >= 0 and i < len(paths) else None))
            while (_g < _g1):
                j = _g
                _g = (_g + 1)
                if (python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).x < result.left):
                    result.left = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).x
                elif (python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).x > result.right):
                    result.right = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).x
                if (python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).y < result.top):
                    result.top = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).y
                elif (python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).y > result.bottom):
                    result.bottom = python_internal_ArrayImpl._get((paths[i] if i >= 0 and i < len(paths) else None), j).y
            i = (i + 1)
        return result



class Clipper(hxClipper_ClipperBase):
    _hx_class_name = u"Clipper"
    __slots__ = (u"mClipType", u"mMaxima", u"mSortedEdges", u"mIntersectList", u"mIntersectNodeComparer", u"mExecuteLocked", u"mClipFillType", u"mSubjFillType", u"mJoins", u"mGhostJoins", u"mUsingPolyTree", u"zFillFunction", u"reverseSolution", u"strictlySimple")
    _hx_fields = [u"mClipType", u"mMaxima", u"mSortedEdges", u"mIntersectList", u"mIntersectNodeComparer", u"mExecuteLocked", u"mClipFillType", u"mSubjFillType", u"mJoins", u"mGhostJoins", u"mUsingPolyTree", u"zFillFunction", u"reverseSolution", u"strictlySimple"]
    _hx_methods = [u"insertMaxima", u"executePaths", u"executePolyTree", u"execute", u"fixHoleLinkage", u"executeInternal", u"disposeAllPolyPts", u"addJoin", u"addGhostJoin", u"setZ", u"insertLocalMinimaIntoAEL", u"insertEdgeIntoAEL", u"e2InsertsBeforeE1", u"isEvenOddFillType", u"isEvenOddAltFillType", u"isContributing", u"setWindingCount", u"addEdgeToSEL", u"popEdgeFromSEL", u"copyAELToSEL", u"swapPositionsInSEL", u"addLocalMaxPoly", u"addLocalMinPoly", u"addOutPt", u"getLastOutPt", u"swapPoints", u"horzSegmentsOverlap", u"setHoleState", u"getDx", u"firstIsBottomPt", u"getBottomPt", u"getLowermostRec", u"outRec1RightOfOutRec2", u"getOutRec", u"appendPolygon", u"reversePolyPtLinks", u"intersectEdges", u"deleteFromSEL", u"processHorizontals", u"getHorzDirection", u"processHorizontal", u"getNextInAEL", u"isMinima", u"isMaxima", u"isIntermediate", u"getMaximaPair", u"getMaximaPairEx", u"processIntersections", u"buildIntersectList", u"edgesAdjacent", u"fixupIntersectionOrder", u"processIntersectList", u"intersectPoint", u"processEdgesAtTopOfScanbeam", u"doMaxima", u"pointCount", u"buildResult", u"buildResult2", u"fixupOutPolyLine", u"fixupOutPolygon", u"dupOutPt", u"getOverlap", u"joinHorz", u"joinPoints", u"fixupFirstLefts1", u"fixupFirstLefts2", u"fixupFirstLefts3", u"joinCommonEdges", u"updateOutPtIdxs", u"doSimplePolygons", u"areaOfOutRec", u"areaOfOutPt"]
    _hx_statics = [u"compare", u"swapSides", u"swapPolyIndexes", u"intersectNodeSort", u"round", u"topX", u"reversePaths", u"orientation", u"pointInPolygon", u"pointInOutPt", u"poly2ContainsPoly1", u"parseFirstLeft", u"area", u"simplifyPolygon", u"simplifyPolygons", u"distanceSqrd", u"distanceFromLineSqrd", u"slopesNearCollinear", u"pointsAreClose", u"excludeOp", u"cleanPolygon", u"cleanPolygons", u"minkowski", u"minkowskiSum", u"translatePath", u"minkowskiSumPaths", u"minkowskiDiff", u"polyTreeToPaths", u"addPolyNodeToPaths", u"openPathsFromPolyTree", u"closedPathsFromPolyTree"]
    _hx_interfaces = []
    _hx_super = hxClipper_ClipperBase


    def __init__(self,initOptions = None):
        if (initOptions is None):
            initOptions = 0
        self.strictlySimple = None
        self.reverseSolution = None
        self.mUsingPolyTree = None
        self.mGhostJoins = None
        self.mJoins = None
        self.mSubjFillType = None
        self.mClipFillType = None
        self.mExecuteLocked = None
        self.mIntersectNodeComparer = None
        self.mIntersectList = None
        self.mSortedEdges = None
        self.mMaxima = None
        self.mClipType = None
        self.zFillFunction = None
        super(Clipper, self).__init__()
        self.mScanbeam = None
        self.mMaxima = None
        self.mActiveEdges = None
        self.mSortedEdges = None
        self.mIntersectList = list()
        self.mIntersectNodeComparer = Clipper.compare
        self.mExecuteLocked = False
        self.mUsingPolyTree = False
        self.mPolyOuts = list()
        self.mJoins = list()
        self.mGhostJoins = list()
        self.reverseSolution = (((1 & initOptions)) != 0)
        self.strictlySimple = (((2 & initOptions)) != 0)
        self.preserveCollinear = (((4 & initOptions)) != 0)
        self.zFillFunction = None

    def insertMaxima(self,x):
        newMax = hxClipper__Clipper_Maxima()
        newMax.x = x
        if (self.mMaxima is None):
            self.mMaxima = newMax
            self.mMaxima.next = None
            self.mMaxima.prev = None
        elif (x < self.mMaxima.x):
            newMax.next = self.mMaxima
            newMax.prev = None
            self.mMaxima = newMax
        else:
            m = self.mMaxima
            while ((m.next is not None) and ((x >= m.next.x))):
                m = m.next
            if (x == m.x):
                return
            newMax.next = m.next
            newMax.prev = m
            if (m.next is not None):
                m.next.prev = newMax
            m.next = newMax

    def executePaths(self,clipType,solution,subjFillType,clipFillType):
        if self.mExecuteLocked:
            return False
        if self.mHasOpenPaths:
            raise haxe_Exception.thrown(ClipperException(u"Error: PolyTree struct is needed for open path clipping."))
        self.mExecuteLocked = True
        _hx_len = len(solution)
        pos = 0
        if (pos < 0):
            pos = (len(solution) + pos)
        if (pos < 0):
            pos = 0
        res = solution[pos:(pos + _hx_len)]
        del solution[pos:(pos + _hx_len)]
        self.mSubjFillType = subjFillType
        self.mClipFillType = clipFillType
        self.mClipType = clipType
        self.mUsingPolyTree = False
        succeeded = False
        succeeded = self.executeInternal()
        if succeeded:
            self.buildResult(solution)
        self.disposeAllPolyPts()
        self.mExecuteLocked = False
        array = self.mJoins
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        array = self.mGhostJoins
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        return succeeded

    def executePolyTree(self,clipType,polytree,subjFillType,clipFillType):
        if self.mExecuteLocked:
            return False
        self.mExecuteLocked = True
        self.mSubjFillType = subjFillType
        self.mClipFillType = clipFillType
        self.mClipType = clipType
        self.mUsingPolyTree = True
        succeeded = False
        succeeded = self.executeInternal()
        if succeeded:
            self.buildResult2(polytree)
        self.disposeAllPolyPts()
        self.mExecuteLocked = False
        array = self.mJoins
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        array = self.mGhostJoins
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        return succeeded

    def execute(self,clipType,solution):
        if Std.isOfType(solution,list):
            return self.executePaths(clipType,solution,PolyFillType.PFT_EVEN_ODD,PolyFillType.PFT_EVEN_ODD)
        elif Std.isOfType(solution,PolyTree):
            return self.executePolyTree(clipType,solution,PolyFillType.PFT_EVEN_ODD,PolyFillType.PFT_EVEN_ODD)
        else:
            raise haxe_Exception.thrown(ClipperException(u"`solution` must be either a Paths or a PolyTree"))

    def fixHoleLinkage(self,outRec):
        if ((outRec.firstLeft is None) or (((outRec.isHole != outRec.firstLeft.isHole) and ((outRec.firstLeft.pts is not None))))):
            return
        orfl = outRec.firstLeft
        while ((orfl is not None) and (((orfl.isHole == outRec.isHole) or ((orfl.pts is None))))):
            orfl = orfl.firstLeft
        outRec.firstLeft = orfl

    def executeInternal(self):
        self.reset()
        self.mSortedEdges = None
        self.mMaxima = None
        topY = None
        popRes = self.popScanbeam()
        botY = popRes.y
        if (not popRes.popped):
            return False
        self.insertLocalMinimaIntoAEL(botY)
        while True:
            popRes = self.popScanbeam()
            topY = popRes.y
            if (popRes.popped or self.localMinimaPending()):
                self.processHorizontals()
                array = self.mGhostJoins
                _hx_len = len(array)
                pos = 0
                if (pos < 0):
                    pos = (len(array) + pos)
                if (pos < 0):
                    pos = 0
                res = array[pos:(pos + _hx_len)]
                del array[pos:(pos + _hx_len)]
                if (not self.processIntersections(topY)):
                    return False
                self.processEdgesAtTopOfScanbeam(topY)
                botY = topY
                self.insertLocalMinimaIntoAEL(botY)
            else:
                break
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            if ((outRec.pts is None) or outRec.isOpen):
                continue
            a = outRec.isHole
            b = self.reverseSolution
            if ((((a and (not b)) or ((b and (not a))))) == ((self.areaOfOutRec(outRec) > 0))):
                self.reversePolyPtLinks(outRec.pts)
        self.joinCommonEdges()
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            if (outRec.pts is None):
                continue
            elif outRec.isOpen:
                self.fixupOutPolyLine(outRec)
            else:
                self.fixupOutPolygon(outRec)
        if self.strictlySimple:
            self.doSimplePolygons()
        return True

    def disposeAllPolyPts(self):
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.disposeOutRec(i)
        array = self.mPolyOuts
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]

    def addJoin(self,op1,op2,offPt):
        j = hxClipper__Clipper_Join()
        j.outPt1 = op1
        j.outPt2 = op2
        j.offPt.copyFrom(offPt)
        _this = self.mJoins
        _this.append(j)

    def addGhostJoin(self,op,offPt):
        j = hxClipper__Clipper_Join()
        j.outPt1 = op
        j.offPt.copyFrom(offPt)
        _this = self.mGhostJoins
        _this.append(j)

    def setZ(self,pt,e1,e2):
        if ((pt.z != 0) or ((self.zFillFunction is None))):
            return
        elif pt.equals(e1.bot):
            pt.z = e1.bot.z
        elif pt.equals(e1.top):
            pt.z = e1.top.z
        elif pt.equals(e2.bot):
            pt.z = e2.bot.z
        elif pt.equals(e2.top):
            pt.z = e2.top.z
        else:
            self.zFillFunction(e1.bot,e1.top,e2.bot,e2.top,pt)

    def insertLocalMinimaIntoAEL(self,botY):
        current = _hx_AnonObject({u'lm': None})
        while self.popLocalMinima(botY,current):
            lm = current.lm
            lb = lm.leftBound
            rb = lm.rightBound
            op1 = None
            if (lb is None):
                self.insertEdgeIntoAEL(rb,None)
                self.setWindingCount(rb)
                if self.isContributing(rb):
                    op1 = self.addOutPt(rb,rb.bot)
            elif (rb is None):
                self.insertEdgeIntoAEL(lb,None)
                self.setWindingCount(lb)
                if self.isContributing(lb):
                    op1 = self.addOutPt(lb,lb.bot)
                self.insertScanbeam(lb.top.y)
            else:
                self.insertEdgeIntoAEL(lb,None)
                self.insertEdgeIntoAEL(rb,lb)
                self.setWindingCount(lb)
                rb.windCnt = lb.windCnt
                rb.windCnt2 = lb.windCnt2
                if self.isContributing(lb):
                    op1 = self.addLocalMinPoly(lb,rb,lb.bot)
                self.insertScanbeam(lb.top.y)
            if (rb is not None):
                if hxClipper_ClipperBase.isHorizontal(rb):
                    if (rb.nextInLML is not None):
                        self.insertScanbeam(rb.nextInLML.top.y)
                    self.addEdgeToSEL(rb)
                else:
                    self.insertScanbeam(rb.top.y)
            if ((lb is None) or ((rb is None))):
                continue
            if ((((op1 is not None) and hxClipper_ClipperBase.isHorizontal(rb)) and ((len(self.mGhostJoins) > 0))) and ((rb.windDelta != 0))):
                _g = 0
                _g1 = len(self.mGhostJoins)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    j = (self.mGhostJoins[i] if i >= 0 and i < len(self.mGhostJoins) else None)
                    if self.horzSegmentsOverlap(j.outPt1.pt.x,j.offPt.x,rb.bot.x,rb.top.x):
                        self.addJoin(j.outPt1,op1,j.offPt)
            if (((((((lb.outIdx >= 0) and ((lb.prevInAEL is not None))) and ((lb.prevInAEL.curr.x == lb.bot.x))) and ((lb.prevInAEL.outIdx >= 0))) and hxClipper_ClipperBase.slopesEqual4(lb.prevInAEL.curr,lb.prevInAEL.top,lb.curr,lb.top,self.mUseFullRange)) and ((lb.windDelta != 0))) and ((lb.prevInAEL.windDelta != 0))):
                op2 = self.addOutPt(lb.prevInAEL,lb.bot)
                self.addJoin(op1,op2,lb.top)
            if (lb.nextInAEL != rb):
                if (((((rb.outIdx >= 0) and ((rb.prevInAEL.outIdx >= 0))) and hxClipper_ClipperBase.slopesEqual4(rb.prevInAEL.curr,rb.prevInAEL.top,rb.curr,rb.top,self.mUseFullRange)) and ((rb.windDelta != 0))) and ((rb.prevInAEL.windDelta != 0))):
                    op21 = self.addOutPt(rb.prevInAEL,rb.bot)
                    self.addJoin(op1,op21,rb.top)
                e = lb.nextInAEL
                if (e is not None):
                    while (e != rb):
                        self.intersectEdges(rb,e,lb.curr)
                        e = e.nextInAEL

    def insertEdgeIntoAEL(self,edge,startEdge):
        if (self.mActiveEdges is None):
            edge.prevInAEL = None
            edge.nextInAEL = None
            self.mActiveEdges = edge
        elif ((startEdge is None) and self.e2InsertsBeforeE1(self.mActiveEdges,edge)):
            edge.prevInAEL = None
            edge.nextInAEL = self.mActiveEdges
            self.mActiveEdges.prevInAEL = edge
            self.mActiveEdges = edge
        else:
            if (startEdge is None):
                startEdge = self.mActiveEdges
            while ((startEdge.nextInAEL is not None) and (not self.e2InsertsBeforeE1(startEdge.nextInAEL,edge))):
                startEdge = startEdge.nextInAEL
            edge.nextInAEL = startEdge.nextInAEL
            if (startEdge.nextInAEL is not None):
                startEdge.nextInAEL.prevInAEL = edge
            edge.prevInAEL = startEdge
            startEdge.nextInAEL = edge

    def e2InsertsBeforeE1(self,e1,e2):
        if (e2.curr.x == e1.curr.x):
            if (e2.top.y > e1.top.y):
                return (e2.top.x < Clipper.topX(e1,e2.top.y))
            else:
                return (e1.top.x > Clipper.topX(e2,e1.top.y))
        else:
            return (e2.curr.x < e1.curr.x)

    def isEvenOddFillType(self,edge):
        if (edge.polyType == PolyType.PT_SUBJECT):
            return (self.mSubjFillType == PolyFillType.PFT_EVEN_ODD)
        else:
            return (self.mClipFillType == PolyFillType.PFT_EVEN_ODD)

    def isEvenOddAltFillType(self,edge):
        if (edge.polyType == PolyType.PT_SUBJECT):
            return (self.mClipFillType == PolyFillType.PFT_EVEN_ODD)
        else:
            return (self.mSubjFillType == PolyFillType.PFT_EVEN_ODD)

    def isContributing(self,edge):
        pft = None
        pft2 = None
        if (edge.polyType == PolyType.PT_SUBJECT):
            pft = self.mSubjFillType
            pft2 = self.mClipFillType
        else:
            pft = self.mClipFillType
            pft2 = self.mSubjFillType
        tmp = pft.index
        if (tmp == 0):
            if ((edge.windDelta == 0) and ((edge.windCnt != 1))):
                return False
        elif (tmp == 1):
            if (Reflect.field(Math,u"fabs")(edge.windCnt) != 1):
                return False
        elif (tmp == 2):
            if (edge.windCnt != 1):
                return False
        elif (edge.windCnt != -1):
            return False
        tmp = self.mClipType.index
        if (tmp == 0):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 != 0)
            elif (tmp == 2):
                return (edge.windCnt2 > 0)
            else:
                return (edge.windCnt2 < 0)
        elif (tmp == 1):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 == 0)
            elif (tmp == 2):
                return (edge.windCnt2 <= 0)
            else:
                return (edge.windCnt2 >= 0)
        elif (tmp == 2):
            if (edge.polyType == PolyType.PT_SUBJECT):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 != 0)
                elif (tmp == 2):
                    return (edge.windCnt2 > 0)
                else:
                    return (edge.windCnt2 < 0)
        elif (tmp == 3):
            if (edge.windDelta == 0):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                return True
        else:
            pass

    def setWindingCount(self,edge):
        e = edge.prevInAEL
        while ((e is not None) and (((e.polyType != edge.polyType) or ((e.windDelta == 0))))):
            e = e.prevInAEL
        if (e is None):
            pft = (self.mSubjFillType if ((edge.polyType == PolyType.PT_SUBJECT)) else self.mClipFillType)
            if (edge.windDelta == 0):
                edge.windCnt = (-1 if ((pft == PolyFillType.PFT_NEGATIVE)) else 1)
            else:
                edge.windCnt = edge.windDelta
            edge.windCnt2 = 0
            e = self.mActiveEdges
        elif ((edge.windDelta == 0) and ((self.mClipType != ClipType.CT_UNION))):
            edge.windCnt = 1
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        elif self.isEvenOddFillType(edge):
            if (edge.windDelta == 0):
                inside = True
                e2 = e.prevInAEL
                while (e2 is not None):
                    if ((e2.polyType == e.polyType) and ((e2.windDelta != 0))):
                        inside = (not inside)
                    e2 = e2.prevInAEL
                edge.windCnt = (0 if inside else 1)
            else:
                edge.windCnt = edge.windDelta
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        else:
            if ((e.windCnt * e.windDelta) < 0):
                if (Reflect.field(Math,u"fabs")(e.windCnt) > 1):
                    if ((e.windDelta * edge.windDelta) < 0):
                        edge.windCnt = e.windCnt
                    else:
                        edge.windCnt = (e.windCnt + edge.windDelta)
                else:
                    edge.windCnt = (1 if ((edge.windDelta == 0)) else edge.windDelta)
            elif (edge.windDelta == 0):
                edge.windCnt = ((e.windCnt - 1) if ((e.windCnt < 0)) else (e.windCnt + 1))
            elif ((e.windDelta * edge.windDelta) < 0):
                edge.windCnt = e.windCnt
            else:
                edge.windCnt = (e.windCnt + edge.windDelta)
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        if self.isEvenOddAltFillType(edge):
            while (e != edge):
                if (e.windDelta != 0):
                    edge.windCnt2 = (1 if ((edge.windCnt2 == 0)) else 0)
                e = e.nextInAEL
        else:
            while (e != edge):
                edge.windCnt2 = (edge.windCnt2 + e.windDelta)
                e = e.nextInAEL

    def addEdgeToSEL(self,edge):
        if (self.mSortedEdges is None):
            self.mSortedEdges = edge
            edge.prevInSEL = None
            edge.nextInSEL = None
        else:
            edge.nextInSEL = self.mSortedEdges
            edge.prevInSEL = None
            self.mSortedEdges.prevInSEL = edge
            self.mSortedEdges = edge

    def popEdgeFromSEL(self):
        res = _hx_AnonObject({u'popped': False, u'edge': None})
        res.edge = self.mSortedEdges
        if (res.edge is None):
            return res
        oldE = res.edge
        self.mSortedEdges = res.edge.nextInSEL
        if (self.mSortedEdges is not None):
            self.mSortedEdges.prevInSEL = None
        oldE.nextInSEL = None
        oldE.prevInSEL = None
        res.popped = True
        return res

    def copyAELToSEL(self):
        e = self.mActiveEdges
        self.mSortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL

    def swapPositionsInSEL(self,edge1,edge2):
        if ((edge1.nextInSEL is None) and ((edge1.prevInSEL is None))):
            return
        if ((edge2.nextInSEL is None) and ((edge2.prevInSEL is None))):
            return
        if (edge1.nextInSEL == edge2):
            next = edge2.nextInSEL
            if (next is not None):
                next.prevInSEL = edge1
            prev = edge1.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge2
            edge2.prevInSEL = prev
            edge2.nextInSEL = edge1
            edge1.prevInSEL = edge2
            edge1.nextInSEL = next
        elif (edge2.nextInSEL == edge1):
            next = edge1.nextInSEL
            if (next is not None):
                next.prevInSEL = edge2
            prev = edge2.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge1
            edge1.prevInSEL = prev
            edge1.nextInSEL = edge2
            edge2.prevInSEL = edge1
            edge2.nextInSEL = next
        else:
            next = edge1.nextInSEL
            prev = edge1.prevInSEL
            edge1.nextInSEL = edge2.nextInSEL
            if (edge1.nextInSEL is not None):
                edge1.nextInSEL.prevInSEL = edge1
            edge1.prevInSEL = edge2.prevInSEL
            if (edge1.prevInSEL is not None):
                edge1.prevInSEL.nextInSEL = edge1
            edge2.nextInSEL = next
            if (edge2.nextInSEL is not None):
                edge2.nextInSEL.prevInSEL = edge2
            edge2.prevInSEL = prev
            if (edge2.prevInSEL is not None):
                edge2.prevInSEL.nextInSEL = edge2
        if (edge1.prevInSEL is None):
            self.mSortedEdges = edge1
        elif (edge2.prevInSEL is None):
            self.mSortedEdges = edge2

    def addLocalMaxPoly(self,e1,e2,pt):
        self.addOutPt(e1,pt)
        if (e2.windDelta == 0):
            self.addOutPt(e2,pt)
        if (e1.outIdx == e2.outIdx):
            e1.outIdx = -1
            e2.outIdx = -1
        elif (e1.outIdx < e2.outIdx):
            self.appendPolygon(e1,e2)
        else:
            self.appendPolygon(e2,e1)

    def addLocalMinPoly(self,e1,e2,pt):
        result = None
        e = None
        prevE = None
        if (hxClipper_ClipperBase.isHorizontal(e2) or ((e1.dx > e2.dx))):
            result = self.addOutPt(e1,pt)
            e2.outIdx = e1.outIdx
            e1.side = hxClipper__Clipper_EdgeSide.ES_LEFT
            e2.side = hxClipper__Clipper_EdgeSide.ES_RIGHT
            e = e1
            if (e.prevInAEL == e2):
                prevE = e2.prevInAEL
            else:
                prevE = e.prevInAEL
        else:
            result = self.addOutPt(e2,pt)
            e1.outIdx = e2.outIdx
            e1.side = hxClipper__Clipper_EdgeSide.ES_RIGHT
            e2.side = hxClipper__Clipper_EdgeSide.ES_LEFT
            e = e2
            if (e.prevInAEL == e1):
                prevE = e1.prevInAEL
            else:
                prevE = e.prevInAEL
        if ((((prevE is not None) and ((prevE.outIdx >= 0))) and ((prevE.top.y < pt.y))) and ((e.top.y < pt.y))):
            xPrev = Clipper.topX(prevE,pt.y)
            xE = Clipper.topX(e,pt.y)
            if ((((xPrev == xE) and ((e.windDelta != 0))) and ((prevE.windDelta != 0))) and hxClipper_ClipperBase.slopesEqual4(IntPoint(xPrev,pt.y),prevE.top,IntPoint(xE,pt.y),e.top,self.mUseFullRange)):
                outPt = self.addOutPt(prevE,pt)
                self.addJoin(result,outPt,e.top)
        return result

    def addOutPt(self,e,pt):
        if (e.outIdx < 0):
            outRec = self.createOutRec()
            outRec.isOpen = (e.windDelta == 0)
            newOp = hxClipper__Clipper_OutPt()
            outRec.pts = newOp
            newOp.idx = outRec.idx
            newOp.pt.copyFrom(pt)
            newOp.next = newOp
            newOp.prev = newOp
            if (not outRec.isOpen):
                self.setHoleState(e,outRec)
            e.outIdx = outRec.idx
            return newOp
        else:
            outRec = python_internal_ArrayImpl._get(self.mPolyOuts, e.outIdx)
            op = outRec.pts
            toFront = (e.side == hxClipper__Clipper_EdgeSide.ES_LEFT)
            if (toFront and pt.equals(op.pt)):
                return op
            elif ((not toFront) and pt.equals(op.prev.pt)):
                return op.prev
            newOp = hxClipper__Clipper_OutPt()
            newOp.idx = outRec.idx
            newOp.pt.copyFrom(pt)
            newOp.next = op
            newOp.prev = op.prev
            newOp.prev.next = newOp
            op.prev = newOp
            if toFront:
                outRec.pts = newOp
            return newOp

    def getLastOutPt(self,e):
        outRec = python_internal_ArrayImpl._get(self.mPolyOuts, e.outIdx)
        if (e.side == hxClipper__Clipper_EdgeSide.ES_LEFT):
            return outRec.pts
        else:
            return outRec.pts.prev

    def swapPoints(self,pt1,pt2):
        tmp = pt1.clone()
        pt1.copyFrom(pt2)
        pt2.copyFrom(tmp)

    def horzSegmentsOverlap(self,seg1a,seg1b,seg2a,seg2b):
        if (seg1a > seg1b):
            tmp = seg1a
            seg1a = seg1b
            seg1b = tmp
        if (seg2a > seg2b):
            tmp = seg2a
            seg2a = seg2b
            seg2b = tmp
        if (seg1a < seg2b):
            return (seg2a < seg1b)
        else:
            return False

    def setHoleState(self,e,outRec):
        e2 = e.prevInAEL
        eTmp = None
        while (e2 is not None):
            if ((e2.outIdx >= 0) and ((e2.windDelta != 0))):
                if (eTmp is None):
                    eTmp = e2
                elif (eTmp.outIdx == e2.outIdx):
                    eTmp = None
            e2 = e2.prevInAEL
        if (eTmp is None):
            outRec.firstLeft = None
            outRec.isHole = False
        else:
            outRec.firstLeft = python_internal_ArrayImpl._get(self.mPolyOuts, eTmp.outIdx)
            outRec.isHole = (not outRec.firstLeft.isHole)

    def getDx(self,pt1,pt2):
        if (pt1.y == pt2.y):
            return -3.4E+38
        else:
            dx = (pt2.x - pt1.x)
            dy = (pt2.y - pt1.y)
            return (dx / dy)

    def firstIsBottomPt(self,btmPt1,btmPt2):
        p = btmPt1.prev
        while (p.pt.equals(btmPt1.pt) and ((p != btmPt1))):
            p = p.prev
        v = self.getDx(btmPt1.pt,p.pt)
        dx1p = Reflect.field(Math,u"fabs")(v)
        p = btmPt1.next
        while (p.pt.equals(btmPt1.pt) and ((p != btmPt1))):
            p = p.next
        v = self.getDx(btmPt1.pt,p.pt)
        dx1n = Reflect.field(Math,u"fabs")(v)
        p = btmPt2.prev
        while (p.pt.equals(btmPt2.pt) and ((p != btmPt2))):
            p = p.prev
        v = self.getDx(btmPt2.pt,p.pt)
        dx2p = Reflect.field(Math,u"fabs")(v)
        p = btmPt2.next
        while (p.pt.equals(btmPt2.pt) and ((p != btmPt2))):
            p = p.next
        v = self.getDx(btmPt2.pt,p.pt)
        dx2n = Reflect.field(Math,u"fabs")(v)
        if ((((dx1p if (python_lib_Math.isnan(dx1p)) else (dx1n if (python_lib_Math.isnan(dx1n)) else max(dx1p,dx1n)))) == ((dx2p if (python_lib_Math.isnan(dx2p)) else (dx2n if (python_lib_Math.isnan(dx2n)) else max(dx2p,dx2n))))) and ((((dx1p if (python_lib_Math.isnan(dx1p)) else (dx1n if (python_lib_Math.isnan(dx1n)) else min(dx1p,dx1n)))) == ((dx2p if (python_lib_Math.isnan(dx2p)) else (dx2n if (python_lib_Math.isnan(dx2n)) else min(dx2p,dx2n))))))):
            return (self.areaOfOutPt(btmPt1) > 0)
        elif (not (((dx1p >= dx2p) and ((dx1p >= dx2n))))):
            if (dx1n >= dx2p):
                return (dx1n >= dx2n)
            else:
                return False
        else:
            return True

    def getBottomPt(self,pp):
        dups = None
        p = pp.next
        while (p != pp):
            if (p.pt.y > pp.pt.y):
                pp = p
                dups = None
            elif ((p.pt.y == pp.pt.y) and ((p.pt.x <= pp.pt.x))):
                if (p.pt.x < pp.pt.x):
                    dups = None
                    pp = p
                elif ((p.next != pp) and ((p.prev != pp))):
                    dups = p
            p = p.next
        if (dups is not None):
            while (dups != p):
                if (not self.firstIsBottomPt(p,dups)):
                    pp = dups
                dups = dups.next
                while (not dups.pt.equals(pp.pt)):
                    dups = dups.next
        return pp

    def getLowermostRec(self,outRec1,outRec2):
        if (outRec1.bottomPt is None):
            outRec1.bottomPt = self.getBottomPt(outRec1.pts)
        if (outRec2.bottomPt is None):
            outRec2.bottomPt = self.getBottomPt(outRec2.pts)
        bPt1 = outRec1.bottomPt
        bPt2 = outRec2.bottomPt
        if (bPt1.pt.y > bPt2.pt.y):
            return outRec1
        elif (bPt1.pt.y < bPt2.pt.y):
            return outRec2
        elif (bPt1.pt.x < bPt2.pt.x):
            return outRec1
        elif (bPt1.pt.x > bPt2.pt.x):
            return outRec2
        elif (bPt1.next == bPt1):
            return outRec2
        elif (bPt2.next == bPt2):
            return outRec1
        elif self.firstIsBottomPt(bPt1,bPt2):
            return outRec1
        else:
            return outRec2

    def outRec1RightOfOutRec2(self,outRec1,outRec2):
        while True:
            outRec1 = outRec1.firstLeft
            if (outRec1 == outRec2):
                return True
            if (not ((outRec1 is not None))):
                break
        return False

    def getOutRec(self,idx):
        outrec = (self.mPolyOuts[idx] if idx >= 0 and idx < len(self.mPolyOuts) else None)
        while (outrec != python_internal_ArrayImpl._get(self.mPolyOuts, outrec.idx)):
            outrec = python_internal_ArrayImpl._get(self.mPolyOuts, outrec.idx)
        return outrec

    def appendPolygon(self,e1,e2):
        outRec1 = python_internal_ArrayImpl._get(self.mPolyOuts, e1.outIdx)
        outRec2 = python_internal_ArrayImpl._get(self.mPolyOuts, e2.outIdx)
        holeStateRec = None
        if self.outRec1RightOfOutRec2(outRec1,outRec2):
            holeStateRec = outRec2
        elif self.outRec1RightOfOutRec2(outRec2,outRec1):
            holeStateRec = outRec1
        else:
            holeStateRec = self.getLowermostRec(outRec1,outRec2)
        p1_lft = outRec1.pts
        p1_rt = p1_lft.prev
        p2_lft = outRec2.pts
        p2_rt = p2_lft.prev
        if (e1.side == hxClipper__Clipper_EdgeSide.ES_LEFT):
            if (e2.side == hxClipper__Clipper_EdgeSide.ES_LEFT):
                self.reversePolyPtLinks(p2_lft)
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                outRec1.pts = p2_rt
            else:
                p2_rt.next = p1_lft
                p1_lft.prev = p2_rt
                p2_lft.prev = p1_rt
                p1_rt.next = p2_lft
                outRec1.pts = p2_lft
        elif (e2.side == hxClipper__Clipper_EdgeSide.ES_RIGHT):
            self.reversePolyPtLinks(p2_lft)
            p1_rt.next = p2_rt
            p2_rt.prev = p1_rt
            p2_lft.next = p1_lft
            p1_lft.prev = p2_lft
        else:
            p1_rt.next = p2_lft
            p2_lft.prev = p1_rt
            p1_lft.prev = p2_rt
            p2_rt.next = p1_lft
        outRec1.bottomPt = None
        if (holeStateRec == outRec2):
            if (outRec2.firstLeft != outRec1):
                outRec1.firstLeft = outRec2.firstLeft
            outRec1.isHole = outRec2.isHole
        outRec2.pts = None
        outRec2.bottomPt = None
        outRec2.firstLeft = outRec1
        OKIdx = e1.outIdx
        ObsoleteIdx = e2.outIdx
        e1.outIdx = -1
        e2.outIdx = -1
        e = self.mActiveEdges
        while (e is not None):
            if (e.outIdx == ObsoleteIdx):
                e.outIdx = OKIdx
                e.side = e1.side
                break
            e = e.nextInAEL
        outRec2.idx = outRec1.idx

    def reversePolyPtLinks(self,pp):
        if (pp is None):
            return
        pp2 = None
        pp1 = pp
        while True:
            pp2 = pp1.next
            pp1.next = pp1.prev
            pp1.prev = pp2
            pp1 = pp2
            if (not ((pp1 != pp))):
                break

    def intersectEdges(self,e1,e2,pt):
        e1Contributing = (e1.outIdx >= 0)
        e2Contributing = (e2.outIdx >= 0)
        self.setZ(pt,e1,e2)
        if ((e1.windDelta == 0) or ((e2.windDelta == 0))):
            if ((e1.windDelta == 0) and ((e2.windDelta == 0))):
                return
            elif (((e1.polyType == e2.polyType) and ((e1.windDelta != e2.windDelta))) and ((self.mClipType == ClipType.CT_UNION))):
                if (e1.windDelta == 0):
                    if e2Contributing:
                        self.addOutPt(e1,pt)
                        if e1Contributing:
                            e1.outIdx = -1
                elif e1Contributing:
                    self.addOutPt(e2,pt)
                    if e2Contributing:
                        e2.outIdx = -1
            elif (e1.polyType != e2.polyType):
                if (((e1.windDelta == 0) and ((Reflect.field(Math,u"fabs")(e2.windCnt) == 1))) and (((self.mClipType != ClipType.CT_UNION) or ((e2.windCnt2 == 0))))):
                    self.addOutPt(e1,pt)
                    if e1Contributing:
                        e1.outIdx = -1
                elif (((e2.windDelta == 0) and ((Reflect.field(Math,u"fabs")(e1.windCnt) == 1))) and (((self.mClipType != ClipType.CT_UNION) or ((e1.windCnt2 == 0))))):
                    self.addOutPt(e2,pt)
                    if e2Contributing:
                        e2.outIdx = -1
            return
        if (e1.polyType == e2.polyType):
            if self.isEvenOddFillType(e1):
                oldE1WindCnt = e1.windCnt
                e1.windCnt = e2.windCnt
                e2.windCnt = oldE1WindCnt
            else:
                if ((e1.windCnt + e2.windDelta) == 0):
                    e1.windCnt = -e1.windCnt
                else:
                    e1.windCnt = (e1.windCnt + e2.windDelta)
                if ((e2.windCnt - e1.windDelta) == 0):
                    e2.windCnt = -e2.windCnt
                else:
                    e2.windCnt = (e2.windCnt - e1.windDelta)
        else:
            if (not self.isEvenOddFillType(e2)):
                e1.windCnt2 = (e1.windCnt2 + e2.windDelta)
            else:
                e1.windCnt2 = (1 if ((e1.windCnt2 == 0)) else 0)
            if (not self.isEvenOddFillType(e1)):
                e2.windCnt2 = (e2.windCnt2 - e1.windDelta)
            else:
                e2.windCnt2 = (1 if ((e2.windCnt2 == 0)) else 0)
        e1FillType = None
        e2FillType = None
        e1FillType2 = None
        e2FillType2 = None
        if (e1.polyType == PolyType.PT_SUBJECT):
            e1FillType = self.mSubjFillType
            e1FillType2 = self.mClipFillType
        else:
            e1FillType = self.mClipFillType
            e1FillType2 = self.mSubjFillType
        if (e2.polyType == PolyType.PT_SUBJECT):
            e2FillType = self.mSubjFillType
            e2FillType2 = self.mClipFillType
        else:
            e2FillType = self.mClipFillType
            e2FillType2 = self.mSubjFillType
        e1Wc = None
        e2Wc = None
        tmp = e1FillType.index
        if (tmp == 2):
            e1Wc = e1.windCnt
        elif (tmp == 3):
            e1Wc = -e1.windCnt
        else:
            x = Reflect.field(Math,u"fabs")(e1.windCnt)
            try:
                e1Wc = int(x)
            except BaseException, _g:
                None
                e1Wc = None
        tmp = e2FillType.index
        if (tmp == 2):
            e2Wc = e2.windCnt
        elif (tmp == 3):
            e2Wc = -e2.windCnt
        else:
            x = Reflect.field(Math,u"fabs")(e2.windCnt)
            try:
                e2Wc = int(x)
            except BaseException, _g:
                None
                e2Wc = None
        if (e1Contributing and e2Contributing):
            if ((((e1Wc != 0) and ((e1Wc != 1))) or (((e2Wc != 0) and ((e2Wc != 1))))) or (((e1.polyType != e2.polyType) and ((self.mClipType != ClipType.CT_XOR))))):
                self.addLocalMaxPoly(e1,e2,pt)
            else:
                self.addOutPt(e1,pt)
                self.addOutPt(e2,pt)
                Clipper.swapSides(e1,e2)
                Clipper.swapPolyIndexes(e1,e2)
        elif e1Contributing:
            if ((e2Wc == 0) or ((e2Wc == 1))):
                self.addOutPt(e1,pt)
                Clipper.swapSides(e1,e2)
                Clipper.swapPolyIndexes(e1,e2)
        elif e2Contributing:
            if ((e1Wc == 0) or ((e1Wc == 1))):
                self.addOutPt(e2,pt)
                Clipper.swapSides(e1,e2)
                Clipper.swapPolyIndexes(e1,e2)
        elif ((((e1Wc == 0) or ((e1Wc == 1)))) and (((e2Wc == 0) or ((e2Wc == 1))))):
            e1Wc2 = None
            e2Wc2 = None
            tmp = e1FillType2.index
            if (tmp == 2):
                e1Wc2 = e1.windCnt2
            elif (tmp == 3):
                e1Wc2 = -e1.windCnt2
            else:
                x = Reflect.field(Math,u"fabs")(e1.windCnt2)
                try:
                    e1Wc2 = int(x)
                except BaseException, _g:
                    None
                    e1Wc2 = None
            tmp = e2FillType2.index
            if (tmp == 2):
                e2Wc2 = e2.windCnt2
            elif (tmp == 3):
                e2Wc2 = -e2.windCnt2
            else:
                x = Reflect.field(Math,u"fabs")(e2.windCnt2)
                try:
                    e2Wc2 = int(x)
                except BaseException, _g:
                    None
                    e2Wc2 = None
            if (e1.polyType != e2.polyType):
                self.addLocalMinPoly(e1,e2,pt)
            elif ((e1Wc == 1) and ((e2Wc == 1))):
                tmp = self.mClipType.index
                if (tmp == 0):
                    if ((e1Wc2 > 0) and ((e2Wc2 > 0))):
                        self.addLocalMinPoly(e1,e2,pt)
                elif (tmp == 1):
                    if ((e1Wc2 <= 0) and ((e2Wc2 <= 0))):
                        self.addLocalMinPoly(e1,e2,pt)
                elif (tmp == 2):
                    if ((((e1.polyType == PolyType.PT_CLIP) and ((e1Wc2 > 0))) and ((e2Wc2 > 0))) or ((((e1.polyType == PolyType.PT_SUBJECT) and ((e1Wc2 <= 0))) and ((e2Wc2 <= 0))))):
                        self.addLocalMinPoly(e1,e2,pt)
                elif (tmp == 3):
                    self.addLocalMinPoly(e1,e2,pt)
                else:
                    pass
            else:
                Clipper.swapSides(e1,e2)

    def deleteFromSEL(self,e):
        selPrev = e.prevInSEL
        selNext = e.nextInSEL
        if (((selPrev is None) and ((selNext is None))) and ((e != self.mSortedEdges))):
            return
        if (selPrev is not None):
            selPrev.nextInSEL = selNext
        else:
            self.mSortedEdges = selNext
        if (selNext is not None):
            selNext.prevInSEL = selPrev
        e.nextInSEL = None
        e.prevInSEL = None

    def processHorizontals(self):
        horzEdge = None
        while True:
            popRes = self.popEdgeFromSEL()
            horzEdge = popRes.edge
            if popRes.popped:
                self.processHorizontal(horzEdge)
            else:
                break

    def getHorzDirection(self,horzEdge,outParams):
        if (horzEdge.bot.x < horzEdge.top.x):
            outParams.left = horzEdge.bot.x
            outParams.right = horzEdge.top.x
            outParams.dir = hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT
        else:
            outParams.left = horzEdge.top.x
            outParams.right = horzEdge.bot.x
            outParams.dir = hxClipper__Clipper_Direction.D_RIGHT_TO_LEFT

    def processHorizontal(self,horzEdge):
        dir = None
        horzLeft = 0
        horzRight = 0
        isOpen = (horzEdge.windDelta == 0)
        outParams = _hx_AnonObject({u'dir': dir, u'left': horzLeft, u'right': horzRight})
        self.getHorzDirection(horzEdge,outParams)
        dir = outParams.dir
        horzLeft = outParams.left
        horzRight = outParams.right
        eLastHorz = horzEdge
        eMaxPair = None
        while ((eLastHorz.nextInLML is not None) and hxClipper_ClipperBase.isHorizontal(eLastHorz.nextInLML)):
            eLastHorz = eLastHorz.nextInLML
        if (eLastHorz.nextInLML is None):
            eMaxPair = self.getMaximaPair(eLastHorz)
        currMax = self.mMaxima
        if (currMax is not None):
            if (dir == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
                while ((currMax is not None) and ((currMax.x <= horzEdge.bot.x))):
                    currMax = currMax.next
                if ((currMax is not None) and ((currMax.x >= eLastHorz.top.x))):
                    currMax = None
            else:
                while ((currMax.next is not None) and ((currMax.next.x < horzEdge.bot.x))):
                    currMax = currMax.next
                if (currMax.x <= eLastHorz.top.x):
                    currMax = None
        op1 = None
        while True:
            isLastHorz = (horzEdge == eLastHorz)
            e = self.getNextInAEL(horzEdge,dir)
            while (e is not None):
                if (currMax is not None):
                    if (dir == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
                        while ((currMax is not None) and ((currMax.x < e.curr.x))):
                            if ((horzEdge.outIdx >= 0) and (not isOpen)):
                                self.addOutPt(horzEdge,IntPoint(currMax.x,horzEdge.bot.y))
                            currMax = currMax.next
                    else:
                        while ((currMax is not None) and ((currMax.x > e.curr.x))):
                            if ((horzEdge.outIdx >= 0) and (not isOpen)):
                                self.addOutPt(horzEdge,IntPoint(currMax.x,horzEdge.bot.y))
                            currMax = currMax.prev
                if (((dir == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT) and ((e.curr.x > horzRight))) or (((dir == hxClipper__Clipper_Direction.D_RIGHT_TO_LEFT) and ((e.curr.x < horzLeft))))):
                    break
                if (((e.curr.x == horzEdge.top.x) and ((horzEdge.nextInLML is not None))) and ((e.dx < horzEdge.nextInLML.dx))):
                    break
                if ((horzEdge.outIdx >= 0) and (not isOpen)):
                    if (dir == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
                        self.setZ(e.curr,horzEdge,e)
                    else:
                        self.setZ(e.curr,e,horzEdge)
                    op1 = self.addOutPt(horzEdge,e.curr)
                    eNextHorz = self.mSortedEdges
                    while (eNextHorz is not None):
                        if ((eNextHorz.outIdx >= 0) and self.horzSegmentsOverlap(horzEdge.bot.x,horzEdge.top.x,eNextHorz.bot.x,eNextHorz.top.x)):
                            op2 = self.getLastOutPt(eNextHorz)
                            self.addJoin(op2,op1,eNextHorz.top)
                        eNextHorz = eNextHorz.nextInSEL
                    self.addGhostJoin(op1,horzEdge.bot)
                if ((e == eMaxPair) and isLastHorz):
                    if (horzEdge.outIdx >= 0):
                        self.addLocalMaxPoly(horzEdge,eMaxPair,horzEdge.top)
                    self.deleteFromAEL(horzEdge)
                    self.deleteFromAEL(eMaxPair)
                    return
                if (dir == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
                    pt = IntPoint(e.curr.x,horzEdge.curr.y)
                    self.intersectEdges(horzEdge,e,pt)
                else:
                    pt1 = IntPoint(e.curr.x,horzEdge.curr.y)
                    self.intersectEdges(e,horzEdge,pt1)
                eNext = self.getNextInAEL(e,dir)
                self.swapPositionsInAEL(horzEdge,e)
                e = eNext
            if ((horzEdge.nextInLML is None) or (not hxClipper_ClipperBase.isHorizontal(horzEdge.nextInLML))):
                break
            horzEdge = self.updateEdgeIntoAEL(horzEdge)
            if (horzEdge.outIdx >= 0):
                self.addOutPt(horzEdge,horzEdge.bot)
            self.getHorzDirection(horzEdge,outParams)
            dir = outParams.dir
            horzLeft = outParams.left
            horzRight = outParams.right
        if ((horzEdge.outIdx >= 0) and ((op1 is None))):
            op1 = self.getLastOutPt(horzEdge)
            eNextHorz = self.mSortedEdges
            while (eNextHorz is not None):
                if ((eNextHorz.outIdx >= 0) and self.horzSegmentsOverlap(horzEdge.bot.x,horzEdge.top.x,eNextHorz.bot.x,eNextHorz.top.x)):
                    op2 = self.getLastOutPt(eNextHorz)
                    self.addJoin(op2,op1,eNextHorz.top)
                eNextHorz = eNextHorz.nextInSEL
            self.addGhostJoin(op1,horzEdge.top)
        if (horzEdge.nextInLML is not None):
            if (horzEdge.outIdx >= 0):
                op1 = self.addOutPt(horzEdge,horzEdge.top)
                horzEdge = self.updateEdgeIntoAEL(horzEdge)
                if (horzEdge.windDelta == 0):
                    return
                ePrev = horzEdge.prevInAEL
                eNext = horzEdge.nextInAEL
                if (((((ePrev is not None) and ((ePrev.curr.x == horzEdge.bot.x))) and ((ePrev.curr.y == horzEdge.bot.y))) and ((ePrev.windDelta != 0))) and ((((ePrev.outIdx >= 0) and ((ePrev.curr.y > ePrev.top.y))) and hxClipper_ClipperBase.slopesEqual(horzEdge,ePrev,self.mUseFullRange)))):
                    op2 = self.addOutPt(ePrev,horzEdge.bot)
                    self.addJoin(op1,op2,horzEdge.top)
                elif (((((((eNext is not None) and ((eNext.curr.x == horzEdge.bot.x))) and ((eNext.curr.y == horzEdge.bot.y))) and ((eNext.windDelta != 0))) and ((eNext.outIdx >= 0))) and ((eNext.curr.y > eNext.top.y))) and hxClipper_ClipperBase.slopesEqual(horzEdge,eNext,self.mUseFullRange)):
                    op2 = self.addOutPt(eNext,horzEdge.bot)
                    self.addJoin(op1,op2,horzEdge.top)
            else:
                horzEdge = self.updateEdgeIntoAEL(horzEdge)
        else:
            if (horzEdge.outIdx >= 0):
                self.addOutPt(horzEdge,horzEdge.top)
            self.deleteFromAEL(horzEdge)

    def getNextInAEL(self,e,direction):
        if (direction == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
            return e.nextInAEL
        else:
            return e.prevInAEL

    def isMinima(self,e):
        if ((e is not None) and ((e.prev.nextInLML != e))):
            return (e.next.nextInLML != e)
        else:
            return False

    def isMaxima(self,e,y):
        if ((e is not None) and ((e.top.y == y))):
            return (e.nextInLML is None)
        else:
            return False

    def isIntermediate(self,e,y):
        if (e.top.y == y):
            return (e.nextInLML is not None)
        else:
            return False

    def getMaximaPair(self,e):
        if (e.next.top.equals(e.top) and ((e.next.nextInLML is None))):
            return e.next
        elif (e.prev.top.equals(e.top) and ((e.prev.nextInLML is None))):
            return e.prev
        else:
            return None

    def getMaximaPairEx(self,e):
        result = self.getMaximaPair(e)
        if (((result is None) or ((result.outIdx == -2))) or (((result.nextInAEL == result.prevInAEL) and (not hxClipper_ClipperBase.isHorizontal(result))))):
            return None
        return result

    def processIntersections(self,topY):
        if (self.mActiveEdges is None):
            return True
        try:
            self.buildIntersectList(topY)
            if (len(self.mIntersectList) == 0):
                return True
            if ((len(self.mIntersectList) == 1) or self.fixupIntersectionOrder()):
                self.processIntersectList()
            else:
                return False
        except BaseException, _g:
            None
            self.mSortedEdges = None
            array = self.mIntersectList
            _hx_len = len(array)
            pos = 0
            if (pos < 0):
                pos = (len(array) + pos)
            if (pos < 0):
                pos = 0
            res = array[pos:(pos + _hx_len)]
            del array[pos:(pos + _hx_len)]
            raise haxe_Exception.thrown(ClipperException(u"ProcessIntersections error"))
        self.mSortedEdges = None
        return True

    def buildIntersectList(self,topY):
        if (self.mActiveEdges is None):
            return
        e = self.mActiveEdges
        self.mSortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e.curr.x = Clipper.topX(e,topY)
            e = e.nextInAEL
        isModified = True
        while (isModified and ((self.mSortedEdges is not None))):
            isModified = False
            e = self.mSortedEdges
            while (e.nextInSEL is not None):
                eNext = e.nextInSEL
                pt = IntPoint()
                if (e.curr.x > eNext.curr.x):
                    self.intersectPoint(e,eNext,pt)
                    if (pt.y < topY):
                        pt = IntPoint(Clipper.topX(e,topY),topY)
                    newNode = IntersectNode()
                    newNode.edge1 = e
                    newNode.edge2 = eNext
                    newNode.pt.copyFrom(pt)
                    _this = self.mIntersectList
                    _this.append(newNode)
                    self.swapPositionsInSEL(e,eNext)
                    isModified = True
                else:
                    e = eNext
            if (e.prevInSEL is not None):
                e.prevInSEL.nextInSEL = None
            else:
                break
        self.mSortedEdges = None

    def edgesAdjacent(self,inode):
        if (inode.edge1.nextInSEL != inode.edge2):
            return (inode.edge1.prevInSEL == inode.edge2)
        else:
            return True

    def fixupIntersectionOrder(self):
        haxe_ds_ArraySort.sort(self.mIntersectList,self.mIntersectNodeComparer)
        self.copyAELToSEL()
        cnt = len(self.mIntersectList)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (not self.edgesAdjacent((self.mIntersectList[i] if i >= 0 and i < len(self.mIntersectList) else None))):
                j = (i + 1)
                while ((j < cnt) and (not self.edgesAdjacent((self.mIntersectList[j] if j >= 0 and j < len(self.mIntersectList) else None)))):
                    j = (j + 1)
                if (j == cnt):
                    return False
                tmp = (self.mIntersectList[i] if i >= 0 and i < len(self.mIntersectList) else None)
                python_internal_ArrayImpl._set(self.mIntersectList, i, (self.mIntersectList[j] if j >= 0 and j < len(self.mIntersectList) else None))
                python_internal_ArrayImpl._set(self.mIntersectList, j, tmp)
            self.swapPositionsInSEL((self.mIntersectList[i] if i >= 0 and i < len(self.mIntersectList) else None).edge1,(self.mIntersectList[i] if i >= 0 and i < len(self.mIntersectList) else None).edge2)
        return True

    def processIntersectList(self):
        _g = 0
        _g1 = len(self.mIntersectList)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            iNode = (self.mIntersectList[i] if i >= 0 and i < len(self.mIntersectList) else None)
            self.intersectEdges(iNode.edge1,iNode.edge2,iNode.pt)
            self.swapPositionsInAEL(iNode.edge1,iNode.edge2)
        array = self.mIntersectList
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]

    def intersectPoint(self,edge1,edge2,ip):
        b1 = None
        b2 = None
        if (edge1.dx == edge2.dx):
            ip.y = edge1.curr.y
            ip.x = Clipper.topX(edge1,ip.y)
            return
        if (edge1.delta.x == 0):
            ip.x = edge1.bot.x
            if hxClipper_ClipperBase.isHorizontal(edge2):
                ip.y = edge2.bot.y
            else:
                b2 = (edge2.bot.y - ((edge2.bot.x / edge2.dx)))
                ip.y = Clipper.round(((ip.x / edge2.dx) + b2))
        elif (edge2.delta.x == 0):
            ip.x = edge2.bot.x
            if hxClipper_ClipperBase.isHorizontal(edge1):
                ip.y = edge1.bot.y
            else:
                b1 = (edge1.bot.y - ((edge1.bot.x / edge1.dx)))
                ip.y = Clipper.round(((ip.x / edge1.dx) + b1))
        else:
            b1 = (edge1.bot.x - ((edge1.bot.y * edge1.dx)))
            b2 = (edge2.bot.x - ((edge2.bot.y * edge2.dx)))
            q = (((b2 - b1)) / ((edge1.dx - edge2.dx)))
            ip.y = Clipper.round(q)
            if (Reflect.field(Math,u"fabs")(edge1.dx) < Reflect.field(Math,u"fabs")(edge2.dx)):
                ip.x = Clipper.round(((edge1.dx * q) + b1))
            else:
                ip.x = Clipper.round(((edge2.dx * q) + b2))
        if ((ip.y < edge1.top.y) or ((ip.y < edge2.top.y))):
            if (edge1.top.y > edge2.top.y):
                ip.y = edge1.top.y
            else:
                ip.y = edge2.top.y
            if (Reflect.field(Math,u"fabs")(edge1.dx) < Reflect.field(Math,u"fabs")(edge2.dx)):
                ip.x = Clipper.topX(edge1,ip.y)
            else:
                ip.x = Clipper.topX(edge2,ip.y)
        if (ip.y > edge1.curr.y):
            ip.y = edge1.curr.y
            if (Reflect.field(Math,u"fabs")(edge1.dx) > Reflect.field(Math,u"fabs")(edge2.dx)):
                ip.x = Clipper.topX(edge2,ip.y)
            else:
                ip.x = Clipper.topX(edge1,ip.y)

    def processEdgesAtTopOfScanbeam(self,topY):
        e = self.mActiveEdges
        while (e is not None):
            isMaximaEdge = self.isMaxima(e,topY)
            if isMaximaEdge:
                eMaxPair = self.getMaximaPairEx(e)
                isMaximaEdge = ((eMaxPair is None) or (not hxClipper_ClipperBase.isHorizontal(eMaxPair)))
            if isMaximaEdge:
                if self.strictlySimple:
                    self.insertMaxima(e.top.x)
                ePrev = e.prevInAEL
                self.doMaxima(e)
                if (ePrev is None):
                    e = self.mActiveEdges
                else:
                    e = ePrev.nextInAEL
            else:
                if (self.isIntermediate(e,topY) and hxClipper_ClipperBase.isHorizontal(e.nextInLML)):
                    e = self.updateEdgeIntoAEL(e)
                    if (e.outIdx >= 0):
                        self.addOutPt(e,e.bot)
                    self.addEdgeToSEL(e)
                else:
                    e.curr.x = Clipper.topX(e,topY)
                    e.curr.y = topY
                    if (e.top.y == topY):
                        e.curr.z = e.top.z
                    elif (e.bot.y == topY):
                        e.curr.z = e.bot.z
                    else:
                        e.curr.z = 0
                if self.strictlySimple:
                    ePrev1 = e.prevInAEL
                    if ((((((e.outIdx >= 0) and ((e.windDelta != 0))) and ((ePrev1 is not None))) and ((ePrev1.outIdx >= 0))) and ((ePrev1.curr.x == e.curr.x))) and ((ePrev1.windDelta != 0))):
                        ip = e.curr.clone()
                        self.setZ(ip,ePrev1,e)
                        op = self.addOutPt(ePrev1,ip)
                        op2 = self.addOutPt(e,ip)
                        self.addJoin(op,op2,ip)
                e = e.nextInAEL
        self.processHorizontals()
        self.mMaxima = None
        e = self.mActiveEdges
        while (e is not None):
            if self.isIntermediate(e,topY):
                op = None
                if (e.outIdx >= 0):
                    op = self.addOutPt(e,e.top)
                e = self.updateEdgeIntoAEL(e)
                ePrev = e.prevInAEL
                eNext = e.nextInAEL
                if (((((((((ePrev is not None) and ((ePrev.curr.x == e.bot.x))) and ((ePrev.curr.y == e.bot.y))) and ((op is not None))) and ((ePrev.outIdx >= 0))) and ((ePrev.curr.y > ePrev.top.y))) and hxClipper_ClipperBase.slopesEqual4(e.curr,e.top,ePrev.curr,ePrev.top,self.mUseFullRange)) and ((e.windDelta != 0))) and ((ePrev.windDelta != 0))):
                    op2 = self.addOutPt(ePrev,e.bot)
                    self.addJoin(op,op2,e.top)
                elif (((((((((eNext is not None) and ((eNext.curr.x == e.bot.x))) and ((eNext.curr.y == e.bot.y))) and ((op is not None))) and ((eNext.outIdx >= 0))) and ((eNext.curr.y > eNext.top.y))) and hxClipper_ClipperBase.slopesEqual4(e.curr,e.top,eNext.curr,eNext.top,self.mUseFullRange)) and ((e.windDelta != 0))) and ((eNext.windDelta != 0))):
                    op21 = self.addOutPt(eNext,e.bot)
                    self.addJoin(op,op21,e.top)
            e = e.nextInAEL

    def doMaxima(self,e):
        eMaxPair = self.getMaximaPairEx(e)
        if (eMaxPair is None):
            if (e.outIdx >= 0):
                self.addOutPt(e,e.top)
            self.deleteFromAEL(e)
            return
        eNext = e.nextInAEL
        while ((eNext is not None) and ((eNext != eMaxPair))):
            self.intersectEdges(e,eNext,e.top)
            self.swapPositionsInAEL(e,eNext)
            eNext = e.nextInAEL
        if ((e.outIdx == -1) and ((eMaxPair.outIdx == -1))):
            self.deleteFromAEL(e)
            self.deleteFromAEL(eMaxPair)
        elif ((e.outIdx >= 0) and ((eMaxPair.outIdx >= 0))):
            if (e.outIdx >= 0):
                self.addLocalMaxPoly(e,eMaxPair,e.top)
            self.deleteFromAEL(e)
            self.deleteFromAEL(eMaxPair)
        elif (e.windDelta == 0):
            if (e.outIdx >= 0):
                self.addOutPt(e,e.top)
                e.outIdx = -1
            self.deleteFromAEL(e)
            if (eMaxPair.outIdx >= 0):
                self.addOutPt(eMaxPair,e.top)
                eMaxPair.outIdx = -1
            self.deleteFromAEL(eMaxPair)
        else:
            raise haxe_Exception.thrown(ClipperException(u"DoMaxima error"))

    def pointCount(self,pts):
        if (pts is None):
            return 0
        result = 0
        p = pts
        while True:
            result = (result + 1)
            p = p.next
            if (not ((p != pts))):
                break
        return result

    def buildResult(self,polyg):
        _hx_len = len(polyg)
        pos = 0
        if (pos < 0):
            pos = (len(polyg) + pos)
        if (pos < 0):
            pos = 0
        res = polyg[pos:(pos + _hx_len)]
        del polyg[pos:(pos + _hx_len)]
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            if (outRec.pts is None):
                continue
            p = outRec.pts.prev
            cnt = self.pointCount(p)
            if (cnt < 2):
                continue
            pg = list()
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = p.pt
                pg.append(x)
                p = p.prev
            polyg.append(pg)

    def buildResult2(self,polytree):
        polytree.clear()
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            cnt = self.pointCount(outRec.pts)
            if ((outRec.isOpen and ((cnt < 2))) or (((not outRec.isOpen) and ((cnt < 3))))):
                continue
            self.fixHoleLinkage(outRec)
            pn = PolyNode()
            _this = polytree.mAllPolys
            _this.append(pn)
            outRec.polyNode = pn
            op = outRec.pts.prev
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                _this1 = pn.mPolygon
                x = op.pt
                _this1.append(x)
                op = op.prev
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            if (outRec.polyNode is None):
                continue
            elif outRec.isOpen:
                outRec.polyNode.isOpen = True
                polytree.addChild(outRec.polyNode)
            elif ((outRec.firstLeft is not None) and ((outRec.firstLeft.polyNode is not None))):
                outRec.firstLeft.polyNode.addChild(outRec.polyNode)
            else:
                polytree.addChild(outRec.polyNode)

    def fixupOutPolyLine(self,outrec):
        pp = outrec.pts
        lastPP = pp.prev
        while (pp != lastPP):
            pp = pp.next
            if (pp.pt == pp.prev.pt):
                if (pp == lastPP):
                    lastPP = pp.prev
                tmpPP = pp.prev
                tmpPP.next = pp.next
                pp.next.prev = tmpPP
                pp = tmpPP
        if (pp == pp.prev):
            outrec.pts = None

    def fixupOutPolygon(self,outRec):
        lastOK = None
        outRec.bottomPt = None
        pp = outRec.pts
        preserveCol = (self.preserveCollinear or self.strictlySimple)
        while True:
            if ((pp.prev == pp) or ((pp.prev == pp.next))):
                outRec.pts = None
                return
            if ((pp.pt.equals(pp.next.pt) or pp.pt.equals(pp.prev.pt)) or ((hxClipper_ClipperBase.slopesEqual3(pp.prev.pt,pp.pt,pp.next.pt,self.mUseFullRange) and (((not preserveCol) or (not self.pt2IsBetweenPt1AndPt3(pp.prev.pt,pp.pt,pp.next.pt))))))):
                lastOK = None
                pp.prev.next = pp.next
                pp.next.prev = pp.prev
                pp = pp.prev
            elif (pp == lastOK):
                break
            else:
                if (lastOK is None):
                    lastOK = pp
                pp = pp.next
        outRec.pts = pp

    def dupOutPt(self,outPt,insertAfter):
        result = hxClipper__Clipper_OutPt()
        result.pt.copyFrom(outPt.pt)
        result.idx = outPt.idx
        if insertAfter:
            result.next = outPt.next
            result.prev = outPt
            outPt.next.prev = result
            outPt.next = result
        else:
            result.prev = outPt.prev
            result.next = outPt
            outPt.prev.next = result
            outPt.prev = result
        return result

    def getOverlap(self,a1,a2,b1,b2,outParams):
        if (a1 < a2):
            if (b1 < b2):
                x = (a1 if (python_lib_Math.isnan(a1)) else (b1 if (python_lib_Math.isnan(b1)) else max(a1,b1)))
                tmp = None
                try:
                    tmp = int(x)
                except BaseException, _g:
                    None
                    tmp = None
                outParams.left = tmp
                x = (a2 if (python_lib_Math.isnan(a2)) else (b2 if (python_lib_Math.isnan(b2)) else min(a2,b2)))
                tmp = None
                try:
                    tmp = int(x)
                except BaseException, _g:
                    None
                    tmp = None
                outParams.right = tmp
            else:
                x = (a1 if (python_lib_Math.isnan(a1)) else (b2 if (python_lib_Math.isnan(b2)) else max(a1,b2)))
                tmp = None
                try:
                    tmp = int(x)
                except BaseException, _g:
                    None
                    tmp = None
                outParams.left = tmp
                x = (a2 if (python_lib_Math.isnan(a2)) else (b1 if (python_lib_Math.isnan(b1)) else min(a2,b1)))
                tmp = None
                try:
                    tmp = int(x)
                except BaseException, _g:
                    None
                    tmp = None
                outParams.right = tmp
        elif (b1 < b2):
            x = (a2 if (python_lib_Math.isnan(a2)) else (b1 if (python_lib_Math.isnan(b1)) else max(a2,b1)))
            tmp = None
            try:
                tmp = int(x)
            except BaseException, _g:
                None
                tmp = None
            outParams.left = tmp
            x = (a1 if (python_lib_Math.isnan(a1)) else (b2 if (python_lib_Math.isnan(b2)) else min(a1,b2)))
            tmp = None
            try:
                tmp = int(x)
            except BaseException, _g:
                None
                tmp = None
            outParams.right = tmp
        else:
            x = (a2 if (python_lib_Math.isnan(a2)) else (b2 if (python_lib_Math.isnan(b2)) else max(a2,b2)))
            tmp = None
            try:
                tmp = int(x)
            except BaseException, _g:
                None
                tmp = None
            outParams.left = tmp
            x = (a1 if (python_lib_Math.isnan(a1)) else (b1 if (python_lib_Math.isnan(b1)) else min(a1,b1)))
            tmp = None
            try:
                tmp = int(x)
            except BaseException, _g:
                None
                tmp = None
            outParams.right = tmp
        return (outParams.left < outParams.right)

    def joinHorz(self,op1,op1b,op2,op2b,pt,discardLeft):
        dir1 = (hxClipper__Clipper_Direction.D_RIGHT_TO_LEFT if ((op1.pt.x > op1b.pt.x)) else hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT)
        dir2 = (hxClipper__Clipper_Direction.D_RIGHT_TO_LEFT if ((op2.pt.x > op2b.pt.x)) else hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT)
        if (dir1 == dir2):
            return False
        if (dir1 == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
            while (((op1.next.pt.x <= pt.x) and ((op1.next.pt.x >= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if (discardLeft and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.dupOutPt(op1,(not discardLeft))
            if (not op1b.pt.equals(pt)):
                op1 = op1b
                op1.pt.copyFrom(pt)
                op1b = self.dupOutPt(op1,(not discardLeft))
        else:
            while (((op1.next.pt.x >= pt.x) and ((op1.next.pt.x <= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if ((not discardLeft) and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.dupOutPt(op1,discardLeft)
            if (not op1b.pt.equals(pt)):
                op1 = op1b
                op1.pt.copyFrom(pt)
                op1b = self.dupOutPt(op1,discardLeft)
        if (dir2 == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT):
            while (((op2.next.pt.x <= pt.x) and ((op2.next.pt.x >= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if (discardLeft and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.dupOutPt(op2,(not discardLeft))
            if (not op2b.pt.equals(pt)):
                op2 = op2b
                op2.pt.copyFrom(pt)
                op2b = self.dupOutPt(op2,(not discardLeft))
        else:
            while (((op2.next.pt.x >= pt.x) and ((op2.next.pt.x <= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if ((not discardLeft) and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.dupOutPt(op2,discardLeft)
            if (not op2b.pt.equals(pt)):
                op2 = op2b
                op2.pt.copyFrom(pt)
                op2b = self.dupOutPt(op2,discardLeft)
        if ((dir1 == hxClipper__Clipper_Direction.D_LEFT_TO_RIGHT) == discardLeft):
            op1.prev = op2
            op2.next = op1
            op1b.next = op2b
            op2b.prev = op1b
        else:
            op1.next = op2
            op2.prev = op1
            op1b.prev = op2b
            op2b.next = op1b
        return True

    def joinPoints(self,j,outRec1,outRec2):
        op1 = j.outPt1
        op1b = None
        op2 = j.outPt2
        op2b = None
        isHorizontal = (j.outPt1.pt.y == j.offPt.y)
        if ((isHorizontal and j.offPt.equals(j.outPt1.pt)) and j.offPt.equals(j.outPt2.pt)):
            if (outRec1 != outRec2):
                return False
            op1b = j.outPt1.next
            while ((op1b != op1) and op1b.pt.equals(j.offPt)):
                op1b = op1b.next
            reverse1 = (op1b.pt.y > j.offPt.y)
            op2b = j.outPt2.next
            while ((op2b != op2) and op2b.pt.equals(j.offPt)):
                op2b = op2b.next
            reverse2 = (op2b.pt.y > j.offPt.y)
            if (reverse1 == reverse2):
                return False
            if reverse1:
                op1b = self.dupOutPt(op1,False)
                op2b = self.dupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.dupOutPt(op1,True)
                op2b = self.dupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
        elif isHorizontal:
            op1b = op1
            while (((op1.prev.pt.y == op1.pt.y) and ((op1.prev != op1b))) and ((op1.prev != op2))):
                op1 = op1.prev
            while (((op1b.next.pt.y == op1b.pt.y) and ((op1b.next != op1))) and ((op1b.next != op2))):
                op1b = op1b.next
            if ((op1b.next == op1) or ((op1b.next == op2))):
                return False
            op2b = op2
            while (((op2.prev.pt.y == op2.pt.y) and ((op2.prev != op2b))) and ((op2.prev != op1b))):
                op2 = op2.prev
            while (((op2b.next.pt.y == op2b.pt.y) and ((op2b.next != op2))) and ((op2b.next != op1))):
                op2b = op2b.next
            if ((op2b.next == op2) or ((op2b.next == op1))):
                return False
            left = 0
            right = 0
            outParams = _hx_AnonObject({u'left': left, u'right': right})
            if (not self.getOverlap(op1.pt.x,op1b.pt.x,op2.pt.x,op2b.pt.x,outParams)):
                return False
            left = outParams.left
            right = outParams.right
            pt = IntPoint()
            discardLeftSide = None
            if ((op1.pt.x >= left) and ((op1.pt.x <= right))):
                pt.copyFrom(op1.pt)
                discardLeftSide = (op1.pt.x > op1b.pt.x)
            elif ((op2.pt.x >= left) and ((op2.pt.x <= right))):
                pt.copyFrom(op2.pt)
                discardLeftSide = (op2.pt.x > op2b.pt.x)
            elif ((op1b.pt.x >= left) and ((op1b.pt.x <= right))):
                pt.copyFrom(op1b.pt)
                discardLeftSide = (op1b.pt.x > op1.pt.x)
            else:
                pt.copyFrom(op2b.pt)
                discardLeftSide = (op2b.pt.x > op2.pt.x)
            j.outPt1 = op1
            j.outPt2 = op2
            return self.joinHorz(op1,op1b,op2,op2b,pt,discardLeftSide)
        else:
            op1b = op1.next
            while (op1b.pt.equals(op1.pt) and ((op1b != op1))):
                op1b = op1b.next
            reverse1 = ((op1b.pt.y > op1.pt.y) or (not hxClipper_ClipperBase.slopesEqual3(op1.pt,op1b.pt,j.offPt,self.mUseFullRange)))
            if reverse1:
                op1b = op1.prev
                while (op1b.pt.equals(op1.pt) and ((op1b != op1))):
                    op1b = op1b.prev
                if ((op1b.pt.y > op1.pt.y) or (not hxClipper_ClipperBase.slopesEqual3(op1.pt,op1b.pt,j.offPt,self.mUseFullRange))):
                    return False
            op2b = op2.next
            while (op2b.pt.equals(op2.pt) and ((op2b != op2))):
                op2b = op2b.next
            reverse2 = ((op2b.pt.y > op2.pt.y) or (not hxClipper_ClipperBase.slopesEqual3(op2.pt,op2b.pt,j.offPt,self.mUseFullRange)))
            if reverse2:
                op2b = op2.prev
                while (op2b.pt.equals(op2.pt) and ((op2b != op2))):
                    op2b = op2b.prev
                if ((op2b.pt.y > op2.pt.y) or (not hxClipper_ClipperBase.slopesEqual3(op2.pt,op2b.pt,j.offPt,self.mUseFullRange))):
                    return False
            if ((((op1b == op1) or ((op2b == op2))) or ((op1b == op2b))) or (((outRec1 == outRec2) and ((reverse1 == reverse2))))):
                return False
            if reverse1:
                op1b = self.dupOutPt(op1,False)
                op2b = self.dupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.dupOutPt(op1,True)
                op2b = self.dupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True

    def fixupFirstLefts1(self,oldOutRec,newOutRec):
        _g = 0
        _g1 = len(self.mPolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outRec = (self.mPolyOuts[i] if i >= 0 and i < len(self.mPolyOuts) else None)
            firstLeft = Clipper.parseFirstLeft(outRec.firstLeft)
            if ((outRec.pts is not None) and ((firstLeft == oldOutRec))):
                if Clipper.poly2ContainsPoly1(outRec.pts,newOutRec.pts):
                    outRec.firstLeft = newOutRec

    def fixupFirstLefts2(self,innerOutRec,outerOutRec):
        orfl = outerOutRec.firstLeft
        _g = 0
        _g1 = self.mPolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((outRec.pts is None) or ((outRec == outerOutRec))) or ((outRec == innerOutRec))):
                continue
            firstLeft = Clipper.parseFirstLeft(outRec.firstLeft)
            if (((firstLeft != orfl) and ((firstLeft != innerOutRec))) and ((firstLeft != outerOutRec))):
                continue
            if Clipper.poly2ContainsPoly1(outRec.pts,innerOutRec.pts):
                outRec.firstLeft = innerOutRec
            elif Clipper.poly2ContainsPoly1(outRec.pts,outerOutRec.pts):
                outRec.firstLeft = outerOutRec
            elif ((outRec.firstLeft == innerOutRec) or ((outRec.firstLeft == outerOutRec))):
                outRec.firstLeft = orfl

    def fixupFirstLefts3(self,oldOutRec,newOutRec):
        _g = 0
        _g1 = self.mPolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            firstLeft = Clipper.parseFirstLeft(outRec.firstLeft)
            if ((outRec.pts is not None) and ((firstLeft == oldOutRec))):
                outRec.firstLeft = newOutRec

    def joinCommonEdges(self):
        _g = 0
        _g1 = len(self.mJoins)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            join = (self.mJoins[i] if i >= 0 and i < len(self.mJoins) else None)
            outRec1 = self.getOutRec(join.outPt1.idx)
            outRec2 = self.getOutRec(join.outPt2.idx)
            if ((outRec1.pts is None) or ((outRec2.pts is None))):
                continue
            if (outRec1.isOpen or outRec2.isOpen):
                continue
            holeStateRec = None
            if (outRec1 == outRec2):
                holeStateRec = outRec1
            elif self.outRec1RightOfOutRec2(outRec1,outRec2):
                holeStateRec = outRec2
            elif self.outRec1RightOfOutRec2(outRec2,outRec1):
                holeStateRec = outRec1
            else:
                holeStateRec = self.getLowermostRec(outRec1,outRec2)
            if (not self.joinPoints(join,outRec1,outRec2)):
                continue
            if (outRec1 == outRec2):
                outRec1.pts = join.outPt1
                outRec1.bottomPt = None
                outRec2 = self.createOutRec()
                outRec2.pts = join.outPt2
                self.updateOutPtIdxs(outRec2)
                if Clipper.poly2ContainsPoly1(outRec2.pts,outRec1.pts):
                    outRec2.isHole = (not outRec1.isHole)
                    outRec2.firstLeft = outRec1
                    if self.mUsingPolyTree:
                        self.fixupFirstLefts2(outRec2,outRec1)
                    a = outRec2.isHole
                    b = self.reverseSolution
                    if ((((a and (not b)) or ((b and (not a))))) == ((self.areaOfOutRec(outRec2) > 0))):
                        self.reversePolyPtLinks(outRec2.pts)
                elif Clipper.poly2ContainsPoly1(outRec1.pts,outRec2.pts):
                    outRec2.isHole = outRec1.isHole
                    outRec1.isHole = (not outRec2.isHole)
                    outRec2.firstLeft = outRec1.firstLeft
                    outRec1.firstLeft = outRec2
                    if self.mUsingPolyTree:
                        self.fixupFirstLefts2(outRec1,outRec2)
                    a1 = outRec1.isHole
                    b1 = self.reverseSolution
                    if ((((a1 and (not b1)) or ((b1 and (not a1))))) == ((self.areaOfOutRec(outRec1) > 0))):
                        self.reversePolyPtLinks(outRec1.pts)
                else:
                    outRec2.isHole = outRec1.isHole
                    outRec2.firstLeft = outRec1.firstLeft
                    if self.mUsingPolyTree:
                        self.fixupFirstLefts1(outRec1,outRec2)
            else:
                outRec2.pts = None
                outRec2.bottomPt = None
                outRec2.idx = outRec1.idx
                outRec1.isHole = holeStateRec.isHole
                if (holeStateRec == outRec2):
                    outRec1.firstLeft = outRec2.firstLeft
                outRec2.firstLeft = outRec1
                if self.mUsingPolyTree:
                    self.fixupFirstLefts3(outRec2,outRec1)

    def updateOutPtIdxs(self,outrec):
        op = outrec.pts
        while True:
            op.idx = outrec.idx
            op = op.prev
            if (not ((op != outrec.pts))):
                break

    def doSimplePolygons(self):
        i = 0
        while (i < len(self.mPolyOuts)):
            outrec = i
            i = (i + 1)
            outrec1 = (self.mPolyOuts[outrec] if outrec >= 0 and outrec < len(self.mPolyOuts) else None)
            op = outrec1.pts
            if ((op is None) or outrec1.isOpen):
                continue
            while True:
                op2 = op.next
                while (op2 != outrec1.pts):
                    if ((op.pt.equals(op2.pt) and ((op2.next != op))) and ((op2.prev != op))):
                        op3 = op.prev
                        op4 = op2.prev
                        op.prev = op4
                        op4.next = op
                        op2.prev = op3
                        op3.next = op2
                        outrec1.pts = op
                        outrec2 = self.createOutRec()
                        outrec2.pts = op2
                        self.updateOutPtIdxs(outrec2)
                        if Clipper.poly2ContainsPoly1(outrec2.pts,outrec1.pts):
                            outrec2.isHole = (not outrec1.isHole)
                            outrec2.firstLeft = outrec1
                            if self.mUsingPolyTree:
                                self.fixupFirstLefts2(outrec2,outrec1)
                        elif Clipper.poly2ContainsPoly1(outrec1.pts,outrec2.pts):
                            outrec2.isHole = outrec1.isHole
                            outrec1.isHole = (not outrec2.isHole)
                            outrec2.firstLeft = outrec1.firstLeft
                            outrec1.firstLeft = outrec2
                            if self.mUsingPolyTree:
                                self.fixupFirstLefts2(outrec1,outrec2)
                        else:
                            outrec2.isHole = outrec1.isHole
                            outrec2.firstLeft = outrec1.firstLeft
                            if self.mUsingPolyTree:
                                self.fixupFirstLefts1(outrec1,outrec2)
                        op2 = op
                    op2 = op2.next
                op = op.next
                if (not ((op != outrec1.pts))):
                    break

    def areaOfOutRec(self,outRec):
        return self.areaOfOutPt(outRec.pts)

    def areaOfOutPt(self,op):
        opFirst = op
        if (op is None):
            return 0
        a = 0
        while True:
            dx = (op.prev.pt.x + op.pt.x)
            dy = (op.prev.pt.y - op.pt.y)
            a = (a + ((dx * dy)))
            op = op.next
            if (not ((op != opFirst))):
                break
        return (a * 0.5)

    @staticmethod
    def compare(node1,node2):
        i = (node2.pt.y - node1.pt.y)
        if (i > 0):
            return 1
        elif (i < 0):
            return -1
        else:
            return 0

    @staticmethod
    def swapSides(edge1,edge2):
        side = edge1.side
        edge1.side = edge2.side
        edge2.side = side

    @staticmethod
    def swapPolyIndexes(edge1,edge2):
        outIdx = edge1.outIdx
        edge1.outIdx = edge2.outIdx
        edge2.outIdx = outIdx

    @staticmethod
    def intersectNodeSort(node1,node2):
        x = (node2.pt.y - node1.pt.y)
        try:
            return int(x)
        except BaseException, _g:
            None
            return None

    @staticmethod
    def round(value):
        if (value < 0):
            tmp = None
            try:
                tmp = int((value - 0.5))
            except BaseException, _g:
                None
                tmp = None
            return tmp
        else:
            tmp = None
            try:
                tmp = int((value + 0.5))
            except BaseException, _g:
                None
                tmp = None
            return tmp

    @staticmethod
    def topX(edge,currentY):
        if (currentY == edge.top.y):
            return edge.top.x
        return (edge.bot.x + Clipper.round((edge.dx * ((currentY - edge.bot.y)))))

    @staticmethod
    def reversePaths(polys):
        _g = 0
        while (_g < len(polys)):
            poly = (polys[_g] if _g >= 0 and _g < len(polys) else None)
            _g = (_g + 1)
            poly.reverse()

    @staticmethod
    def orientation(poly):
        return (Clipper.area(poly) >= 0)

    @staticmethod
    def pointInPolygon(pt,path):
        result = 0
        cnt = len(path)
        if (cnt < 3):
            return 0
        ip = (path[0] if 0 < len(path) else None).clone()
        ipNext = IntPoint()
        _g = 1
        _g1 = (cnt + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ipNext.copyFrom(((path[0] if 0 < len(path) else None) if ((i == cnt)) else (path[i] if i >= 0 and i < len(path) else None)))
            if (ipNext.y == pt.y):
                if ((ipNext.x == pt.x) or (((ip.y == pt.y) and (((ipNext.x > pt.x) == ((ip.x < pt.x))))))):
                    return -1
            if ((ip.y < pt.y) != ((ipNext.y < pt.y))):
                if (ip.x >= pt.x):
                    if (ipNext.x > pt.x):
                        result = (1 - result)
                    else:
                        dx = (ip.x - pt.x)
                        dy = (ip.y - pt.y)
                        d = ((dx * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * dy)))
                        if (d == 0):
                            return -1
                        elif ((d > 0) == ((ipNext.y > ip.y))):
                            result = (1 - result)
                elif (ipNext.x > pt.x):
                    dx1 = (ip.x - pt.x)
                    dy1 = (ip.y - pt.y)
                    d1 = ((dx1 * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * dy1)))
                    if (d1 == 0):
                        return -1
                    elif ((d1 > 0) == ((ipNext.y > ip.y))):
                        result = (1 - result)
            ip.copyFrom(ipNext)
        return result

    @staticmethod
    def pointInOutPt(pt,op):
        result = 0
        startOp = op
        ptx = pt.x
        pty = pt.y
        poly0x = op.pt.x
        poly0y = op.pt.y
        while True:
            op = op.next
            poly1x = op.pt.x
            poly1y = op.pt.y
            if (poly1y == pty):
                if ((poly1x == ptx) or (((poly0y == pty) and (((poly1x > ptx) == ((poly0x < ptx))))))):
                    return -1
            if ((poly0y < pty) != ((poly1y < pty))):
                if (poly0x >= ptx):
                    if (poly1x > ptx):
                        result = (1 - result)
                    else:
                        dx = (poly0x - ptx)
                        dy = (poly0y - pty)
                        d = ((dx * ((poly1y - pty))) - ((((poly1x - ptx)) * dy)))
                        if (d == 0):
                            return -1
                        if ((d > 0) == ((poly1y > poly0y))):
                            result = (1 - result)
                elif (poly1x > ptx):
                    dx1 = (poly0x - ptx)
                    dy1 = (poly0y - pty)
                    d1 = ((dx1 * ((poly1y - pty))) - ((((poly1x - ptx)) * dy1)))
                    if (d1 == 0):
                        return -1
                    if ((d1 > 0) == ((poly1y > poly0y))):
                        result = (1 - result)
            poly0x = poly1x
            poly0y = poly1y
            if (not ((startOp != op))):
                break
        return result

    @staticmethod
    def poly2ContainsPoly1(outPt1,outPt2):
        op = outPt1
        while True:
            res = Clipper.pointInOutPt(op.pt,outPt2)
            if (res >= 0):
                return (res > 0)
            op = op.next
            if (not ((op != outPt1))):
                break
        return True

    @staticmethod
    def parseFirstLeft(firstLeft):
        while ((firstLeft is not None) and ((firstLeft.pts is None))):
            firstLeft = firstLeft.firstLeft
        return firstLeft

    @staticmethod
    def area(poly):
        if ((poly is None) or ((len(poly) < 3))):
            return 0
        cnt = len(poly)
        a = 0
        j = (cnt - 1)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            dx = ((poly[j] if j >= 0 and j < len(poly) else None).x + (poly[i] if i >= 0 and i < len(poly) else None).x)
            dy = ((poly[j] if j >= 0 and j < len(poly) else None).y - (poly[i] if i >= 0 and i < len(poly) else None).y)
            a = (a + ((dx * dy)))
            j = i
        return (-a * 0.5)

    @staticmethod
    def simplifyPolygon(poly,fillType = None):
        if (fillType is None):
            fillType = PolyFillType.PFT_EVEN_ODD
        result = list()
        c = Clipper()
        c.strictlySimple = True
        c.addPath(poly,PolyType.PT_SUBJECT,True)
        c.executePaths(ClipType.CT_UNION,result,fillType,fillType)
        return result

    @staticmethod
    def simplifyPolygons(polys,fillType = None):
        if (fillType is None):
            fillType = PolyFillType.PFT_EVEN_ODD
        result = list()
        c = Clipper()
        c.strictlySimple = True
        c.addPaths(polys,PolyType.PT_SUBJECT,True)
        c.executePaths(ClipType.CT_UNION,result,fillType,fillType)
        return result

    @staticmethod
    def distanceSqrd(pt1,pt2):
        dx = (pt1.x - pt2.x)
        dy = (pt1.y - pt2.y)
        return ((dx * dx) + ((dy * dy)))

    @staticmethod
    def distanceFromLineSqrd(pt,ln1,ln2):
        A = (ln1.y - ln2.y)
        B = (ln2.x - ln1.x)
        C = ((A * ln1.x) + ((B * ln1.y)))
        C = (((A * pt.x) + ((B * pt.y))) - C)
        return ((C * C) / (((A * A) + ((B * B)))))

    @staticmethod
    def slopesNearCollinear(pt1,pt2,pt3,distSqrd):
        if (Reflect.field(Math,u"fabs")((pt1.x - pt2.x)) > Reflect.field(Math,u"fabs")((pt1.y - pt2.y))):
            if ((pt1.x > pt2.x) == ((pt1.x < pt3.x))):
                return (Clipper.distanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
            elif ((pt2.x > pt1.x) == ((pt2.x < pt3.x))):
                return (Clipper.distanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
            else:
                return (Clipper.distanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)
        elif ((pt1.y > pt2.y) == ((pt1.y < pt3.y))):
            return (Clipper.distanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
        elif ((pt2.y > pt1.y) == ((pt2.y < pt3.y))):
            return (Clipper.distanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
        else:
            return (Clipper.distanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)

    @staticmethod
    def pointsAreClose(pt1,pt2,distSqrd):
        dx = (pt1.x - pt2.x)
        dy = (pt1.y - pt2.y)
        return (((dx * dx) + ((dy * dy))) <= distSqrd)

    @staticmethod
    def excludeOp(op):
        result = op.prev
        result.next = op.next
        op.next.prev = result
        result.idx = 0
        return result

    @staticmethod
    def cleanPolygon(path,distance = None):
        if (distance is None):
            distance = 1.415
        cnt = len(path)
        if (cnt == 0):
            return list()
        _g = []
        _g1 = 0
        _g2 = cnt
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = hxClipper__Clipper_OutPt()
            _g.append(x)
        outPts = _g
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            (outPts[i] if i >= 0 and i < len(outPts) else None).pt.copyFrom((path[i] if i >= 0 and i < len(path) else None))
            (outPts[i] if i >= 0 and i < len(outPts) else None).next = python_internal_ArrayImpl._get(outPts, HxOverrides.mod(((i + 1)), cnt))
            (outPts[i] if i >= 0 and i < len(outPts) else None).next.prev = (outPts[i] if i >= 0 and i < len(outPts) else None)
            (outPts[i] if i >= 0 and i < len(outPts) else None).idx = 0
        distSqrd = (distance * distance)
        op = (outPts[0] if 0 < len(outPts) else None)
        while ((op.idx == 0) and ((op.next != op.prev))):
            if Clipper.pointsAreClose(op.pt,op.prev.pt,distSqrd):
                op = Clipper.excludeOp(op)
                cnt = (cnt - 1)
            elif Clipper.pointsAreClose(op.prev.pt,op.next.pt,distSqrd):
                Clipper.excludeOp(op.next)
                op = Clipper.excludeOp(op)
                cnt = (cnt - 2)
            elif Clipper.slopesNearCollinear(op.prev.pt,op.pt,op.next.pt,distSqrd):
                op = Clipper.excludeOp(op)
                cnt = (cnt - 1)
            else:
                op.idx = 1
                op = op.next
        if (cnt < 3):
            cnt = 0
        result = list()
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = op.pt
            result.append(x)
            op = op.next
        outPts = None
        return result

    @staticmethod
    def cleanPolygons(polys,distance = None):
        if (distance is None):
            distance = 1.415
        result = list()
        _g = 0
        _g1 = len(polys)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = Clipper.cleanPolygon((polys[i] if i >= 0 and i < len(polys) else None),distance)
            result.append(x)
        return result

    @staticmethod
    def minkowski(pattern,path,isSum,isClosed):
        delta = (1 if isClosed else 0)
        polyCnt = len(pattern)
        pathCnt = len(path)
        result = list()
        if isSum:
            _g = 0
            _g1 = pathCnt
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = list()
                _g2 = 0
                while (_g2 < len(pattern)):
                    ip = (pattern[_g2] if _g2 >= 0 and _g2 < len(pattern) else None)
                    _g2 = (_g2 + 1)
                    x = IntPoint(((path[i] if i >= 0 and i < len(path) else None).x + ip.x),((path[i] if i >= 0 and i < len(path) else None).y + ip.y))
                    p.append(x)
                result.append(p)
        else:
            _g = 0
            _g1 = pathCnt
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = list()
                _g2 = 0
                while (_g2 < len(pattern)):
                    ip = (pattern[_g2] if _g2 >= 0 and _g2 < len(pattern) else None)
                    _g2 = (_g2 + 1)
                    x = IntPoint(((path[i] if i >= 0 and i < len(path) else None).x - ip.x),((path[i] if i >= 0 and i < len(path) else None).y - ip.y))
                    p.append(x)
                result.append(p)
        quads = list()
        _g = 0
        _g1 = ((pathCnt - 1) + delta)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = polyCnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                quad = list()
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                if (not Clipper.orientation(quad)):
                    quad.reverse()
                quads.append(quad)
        return quads

    @staticmethod
    def minkowskiSum(pattern,path,pathIsClosed):
        paths = Clipper.minkowski(pattern,path,True,pathIsClosed)
        c = Clipper()
        c.addPaths(paths,PolyType.PT_SUBJECT,True)
        c.executePaths(ClipType.CT_UNION,paths,PolyFillType.PFT_NON_ZERO,PolyFillType.PFT_NON_ZERO)
        return paths

    @staticmethod
    def translatePath(path,delta):
        outPath = list()
        _g = 0
        _g1 = len(path)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = IntPoint(((path[i] if i >= 0 and i < len(path) else None).x + delta.x),((path[i] if i >= 0 and i < len(path) else None).y + delta.y))
            outPath.append(x)
        return outPath

    @staticmethod
    def minkowskiSumPaths(pattern,paths,pathIsClosed):
        solution = list()
        c = Clipper()
        _g = 0
        _g1 = len(paths)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = Clipper.minkowski(pattern,(paths[i] if i >= 0 and i < len(paths) else None),True,pathIsClosed)
            c.addPaths(tmp,PolyType.PT_SUBJECT,True)
            if pathIsClosed:
                path = Clipper.translatePath((paths[i] if i >= 0 and i < len(paths) else None),(pattern[0] if 0 < len(pattern) else None))
                c.addPath(path,PolyType.PT_CLIP,True)
        c.executePaths(ClipType.CT_UNION,solution,PolyFillType.PFT_NON_ZERO,PolyFillType.PFT_NON_ZERO)
        return solution

    @staticmethod
    def minkowskiDiff(poly1,poly2):
        paths = Clipper.minkowski(poly1,poly2,False,True)
        c = Clipper()
        c.addPaths(paths,PolyType.PT_SUBJECT,True)
        c.executePaths(ClipType.CT_UNION,paths,PolyFillType.PFT_NON_ZERO,PolyFillType.PFT_NON_ZERO)
        return paths

    @staticmethod
    def polyTreeToPaths(polytree):
        result = list()
        Clipper.addPolyNodeToPaths(polytree,hxClipper__Clipper_NodeType.NT_ANY,result)
        return result

    @staticmethod
    def addPolyNodeToPaths(polynode,nt,paths):
        match = True
        tmp = nt.index
        if (tmp == 1):
            return
        elif (tmp == 2):
            match = (not polynode.isOpen)
        else:
            pass
        if ((len(polynode.mPolygon) > 0) and match):
            x = polynode.mPolygon
            paths.append(x)
        _g = 0
        _g1 = polynode.get_children()
        while (_g < len(_g1)):
            pn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            Clipper.addPolyNodeToPaths(pn,nt,paths)

    @staticmethod
    def openPathsFromPolyTree(polytree):
        result = list()
        _g = 0
        _g1 = polytree.get_numChildren()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if python_internal_ArrayImpl._get(polytree.get_children(), i).isOpen:
                x = python_internal_ArrayImpl._get(polytree.get_children(), i).mPolygon
                result.append(x)
        return result

    @staticmethod
    def closedPathsFromPolyTree(polytree):
        result = list()
        Clipper.addPolyNodeToPaths(polytree,hxClipper__Clipper_NodeType.NT_CLOSED,result)
        return result



class ClipperOffset(object):
    _hx_class_name = u"ClipperOffset"
    __slots__ = (u"mDestPolys", u"mSrcPoly", u"mDestPoly", u"mNormals", u"mDelta", u"mSinA", u"mSin", u"mCos", u"mMiterLim", u"mStepsPerRad", u"mLowest", u"mPolyNodes", u"arcTolerance", u"miterLimit")
    _hx_fields = [u"mDestPolys", u"mSrcPoly", u"mDestPoly", u"mNormals", u"mDelta", u"mSinA", u"mSin", u"mCos", u"mMiterLim", u"mStepsPerRad", u"mLowest", u"mPolyNodes", u"arcTolerance", u"miterLimit"]
    _hx_methods = [u"clear", u"addPath", u"addPaths", u"fixOrientations", u"doOffset", u"execute", u"executePaths", u"executePolyTree", u"offsetPoint", u"doSquare", u"doMiter", u"doRound"]
    _hx_statics = [u"TWO_PI", u"DEFAULT_ARC_TOLERANCE", u"round", u"getUnitNormal"]

    def __init__(self,miterLimit = None,arcTolerance = None):
        if (miterLimit is None):
            miterLimit = 2.0
        if (arcTolerance is None):
            arcTolerance = 0.25
        self.mStepsPerRad = None
        self.mMiterLim = None
        self.mCos = None
        self.mSin = None
        self.mSinA = None
        self.mDelta = None
        self.mDestPoly = None
        self.mSrcPoly = None
        self.mDestPolys = None
        self.mPolyNodes = PolyNode()
        self.mLowest = IntPoint()
        self.mNormals = list()
        self.miterLimit = miterLimit
        self.arcTolerance = arcTolerance
        self.mLowest.x = -1

    def clear(self):
        array = self.mPolyNodes.get_children()
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]
        self.mLowest.x = -1

    def addPath(self,path,joinType,endType):
        highI = (len(path) - 1)
        if (highI < 0):
            return
        newNode = PolyNode()
        newNode.mJoinType = joinType
        newNode.mEndtype = endType
        if ((endType == EndType.ET_CLOSED_LINE) or ((endType == EndType.ET_CLOSED_POLYGON))):
            while ((highI > 0) and (path[0] if 0 < len(path) else None).equals((path[highI] if highI >= 0 and highI < len(path) else None))):
                highI = (highI - 1)
        _this = newNode.mPolygon
        _this.append((path[0] if 0 < len(path) else None))
        j = 0
        k = 0
        _g = 1
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (not (newNode.mPolygon[j] if j >= 0 and j < len(newNode.mPolygon) else None).equals((path[i] if i >= 0 and i < len(path) else None))):
                j = (j + 1)
                _this = newNode.mPolygon
                _this.append((path[i] if i >= 0 and i < len(path) else None))
                if (((path[i] if i >= 0 and i < len(path) else None).y > (newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).y) or ((((path[i] if i >= 0 and i < len(path) else None).y == (newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).y) and (((path[i] if i >= 0 and i < len(path) else None).x < (newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).x))))):
                    k = j
        if ((endType == EndType.ET_CLOSED_POLYGON) and ((j < 2))):
            return
        self.mPolyNodes.addChild(newNode)
        if (endType != EndType.ET_CLOSED_POLYGON):
            return
        if (self.mLowest.x < 0):
            self.mLowest = IntPoint((self.mPolyNodes.get_numChildren() - 1),k)
        else:
            ip = self.mPolyNodes.get_children()
            x = self.mLowest.x
            ip1 = None
            try:
                ip1 = int(x)
            except BaseException, _g:
                None
                ip1 = None
            ip2 = (ip[ip1] if ip1 >= 0 and ip1 < len(ip) else None).mPolygon
            x = self.mLowest.y
            ip = None
            try:
                ip = int(x)
            except BaseException, _g:
                None
                ip = None
            ip1 = (ip2[ip] if ip >= 0 and ip < len(ip2) else None).clone()
            if (((newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).y > ip1.y) or ((((newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).y == ip1.y) and (((newNode.mPolygon[k] if k >= 0 and k < len(newNode.mPolygon) else None).x < ip1.x))))):
                self.mLowest = IntPoint((self.mPolyNodes.get_numChildren() - 1),k)

    def addPaths(self,paths,joinType,endType):
        _g = 0
        while (_g < len(paths)):
            p = (paths[_g] if _g >= 0 and _g < len(paths) else None)
            _g = (_g + 1)
            self.addPath(p,joinType,endType)

    def fixOrientations(self):
        tmp = None
        if (self.mLowest.x >= 0):
            tmp1 = self.mPolyNodes.get_children()
            x = self.mLowest.x
            tmp2 = None
            try:
                tmp2 = int(x)
            except BaseException, _g:
                None
                tmp2 = None
            tmp = (not Clipper.orientation((tmp1[tmp2] if tmp2 >= 0 and tmp2 < len(tmp1) else None).mPolygon))
        else:
            tmp = False
        if tmp:
            _g = 0
            _g1 = self.mPolyNodes.get_numChildren()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                node = python_internal_ArrayImpl._get(self.mPolyNodes.get_children(), i)
                if ((node.mEndtype == EndType.ET_CLOSED_POLYGON) or (((node.mEndtype == EndType.ET_CLOSED_LINE) and Clipper.orientation(node.mPolygon)))):
                    node.mPolygon.reverse()
        else:
            _g = 0
            _g1 = self.mPolyNodes.get_numChildren()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                node = python_internal_ArrayImpl._get(self.mPolyNodes.get_children(), i)
                if ((node.mEndtype == EndType.ET_CLOSED_LINE) and (not Clipper.orientation(node.mPolygon))):
                    node.mPolygon.reverse()

    def doOffset(self,delta):
        self.mDestPolys = list()
        self.mDelta = delta
        if hxClipper_ClipperBase.nearZero(delta):
            _g = 0
            _g1 = self.mPolyNodes.get_numChildren()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                node = python_internal_ArrayImpl._get(self.mPolyNodes.get_children(), i)
                if (node.mEndtype == EndType.ET_CLOSED_POLYGON):
                    _this = self.mDestPolys
                    x = node.mPolygon
                    _this.append(x)
            return
        if (self.miterLimit > 2):
            self.mMiterLim = (2 / ((self.miterLimit * self.miterLimit)))
        else:
            self.mMiterLim = 0.5
        y = None
        if (self.arcTolerance <= 0.0):
            y = 0.25
        elif (self.arcTolerance > ((Reflect.field(Math,u"fabs")(delta) * 0.25))):
            y = (Reflect.field(Math,u"fabs")(delta) * 0.25)
        else:
            y = self.arcTolerance
        steps = (Math.PI / Math.acos((1 - ((y / Reflect.field(Math,u"fabs")(delta))))))
        v = (6.283185307179586476925286766559 / steps)
        self.mSin = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v))
        v = (6.283185307179586476925286766559 / steps)
        self.mCos = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v))
        self.mStepsPerRad = (steps / 6.283185307179586476925286766559)
        if (delta < 0.0):
            self.mSin = -self.mSin
        _g = 0
        _g1 = self.mPolyNodes.get_numChildren()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            node = python_internal_ArrayImpl._get(self.mPolyNodes.get_children(), i)
            self.mSrcPoly = node.mPolygon
            _hx_len = len(self.mSrcPoly)
            if ((_hx_len == 0) or (((delta <= 0) and (((_hx_len < 3) or ((node.mEndtype != EndType.ET_CLOSED_POLYGON))))))):
                continue
            self.mDestPoly = list()
            if (_hx_len == 1):
                if (node.mJoinType == JoinType.JT_ROUND):
                    x = 1.0
                    y = 0.0
                    j = 1
                    while (j <= steps):
                        _this = self.mDestPoly
                        x1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + ((x * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + ((y * delta)))))
                        _this.append(x1)
                        x2 = x
                        x = ((x * self.mCos) - ((self.mSin * y)))
                        y = ((x2 * self.mSin) + ((y * self.mCos)))
                        j = (j + 1)
                else:
                    x3 = -1.0
                    y1 = -1.0
                    _this1 = self.mDestPoly
                    x4 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + ((x3 * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + ((y1 * delta)))))
                    _this1.append(x4)
                    if (x3 < 0):
                        x3 = 1
                    elif (y1 < 0):
                        y1 = 1
                    else:
                        x3 = -1
                    _this2 = self.mDestPoly
                    x5 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + ((x3 * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + ((y1 * delta)))))
                    _this2.append(x5)
                    if (x3 < 0):
                        x3 = 1
                    elif (y1 < 0):
                        y1 = 1
                    else:
                        x3 = -1
                    _this3 = self.mDestPoly
                    x6 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + ((x3 * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + ((y1 * delta)))))
                    _this3.append(x6)
                    if (x3 < 0):
                        x3 = 1
                    elif (y1 < 0):
                        y1 = 1
                    else:
                        x3 = -1
                    _this4 = self.mDestPoly
                    x7 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + ((x3 * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + ((y1 * delta)))))
                    _this4.append(x7)
                    if (x3 < 0):
                        x3 = 1
                    elif (y1 < 0):
                        y1 = 1
                    else:
                        x3 = -1
                _this5 = self.mDestPolys
                x8 = self.mDestPoly
                _this5.append(x8)
                continue
            array = self.mNormals
            len1 = len(array)
            pos = 0
            if (pos < 0):
                pos = (len(array) + pos)
            if (pos < 0):
                pos = 0
            res = array[pos:(pos + len1)]
            del array[pos:(pos + len1)]
            _g2 = 0
            _g3 = (_hx_len - 1)
            while (_g2 < _g3):
                j1 = _g2
                _g2 = (_g2 + 1)
                _this6 = self.mNormals
                x9 = ClipperOffset.getUnitNormal((self.mSrcPoly[j1] if j1 >= 0 and j1 < len(self.mSrcPoly) else None),python_internal_ArrayImpl._get(self.mSrcPoly, (j1 + 1)))
                _this6.append(x9)
            if ((node.mEndtype == EndType.ET_CLOSED_LINE) or ((node.mEndtype == EndType.ET_CLOSED_POLYGON))):
                _this7 = self.mNormals
                x10 = ClipperOffset.getUnitNormal(python_internal_ArrayImpl._get(self.mSrcPoly, (_hx_len - 1)),(self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None))
                _this7.append(x10)
            else:
                _this8 = self.mNormals
                x11 = python_internal_ArrayImpl._get(self.mNormals, (_hx_len - 2)).clone()
                _this8.append(x11)
            if (node.mEndtype == EndType.ET_CLOSED_POLYGON):
                k = (_hx_len - 1)
                _g4 = 0
                _g5 = _hx_len
                while (_g4 < _g5):
                    j2 = _g4
                    _g4 = (_g4 + 1)
                    k = self.offsetPoint(j2,k,node.mJoinType)
                _this9 = self.mDestPolys
                x12 = self.mDestPoly
                _this9.append(x12)
            elif (node.mEndtype == EndType.ET_CLOSED_LINE):
                k1 = (_hx_len - 1)
                _g6 = 0
                _g7 = _hx_len
                while (_g6 < _g7):
                    j3 = _g6
                    _g6 = (_g6 + 1)
                    k1 = self.offsetPoint(j3,k1,node.mJoinType)
                _this10 = self.mDestPolys
                x13 = self.mDestPoly
                _this10.append(x13)
                self.mDestPoly = list()
                n = python_internal_ArrayImpl._get(self.mNormals, (_hx_len - 1)).clone()
                nj = (_hx_len - 1)
                while (nj > 0):
                    python_internal_ArrayImpl._set(self.mNormals, nj, DoublePoint(-python_internal_ArrayImpl._get(self.mNormals, (nj - 1)).x,-python_internal_ArrayImpl._get(self.mNormals, (nj - 1)).y))
                    nj = (nj - 1)
                python_internal_ArrayImpl._set(self.mNormals, 0, DoublePoint(-n.x,-n.y))
                k1 = 0
                nj = (_hx_len - 1)
                while (nj >= 0):
                    k1 = self.offsetPoint(nj,k1,node.mJoinType)
                    nj = (nj - 1)
                _this11 = self.mDestPolys
                x14 = self.mDestPoly
                _this11.append(x14)
            else:
                k2 = 0
                _g8 = 1
                _g9 = (_hx_len - 1)
                while (_g8 < _g9):
                    j4 = _g8
                    _g8 = (_g8 + 1)
                    k2 = self.offsetPoint(j4,k2,node.mJoinType)
                pt1 = None
                if (node.mEndtype == EndType.ET_OPEN_BUTT):
                    j5 = (_hx_len - 1)
                    pt1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[j5] if j5 >= 0 and j5 < len(self.mSrcPoly) else None).x + (((self.mNormals[j5] if j5 >= 0 and j5 < len(self.mNormals) else None).x * delta)))),ClipperOffset.round(((self.mSrcPoly[j5] if j5 >= 0 and j5 < len(self.mSrcPoly) else None).y + (((self.mNormals[j5] if j5 >= 0 and j5 < len(self.mNormals) else None).y * delta)))))
                    _this12 = self.mDestPoly
                    _this12.append(pt1)
                    pt1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[j5] if j5 >= 0 and j5 < len(self.mSrcPoly) else None).x - (((self.mNormals[j5] if j5 >= 0 and j5 < len(self.mNormals) else None).x * delta)))),ClipperOffset.round(((self.mSrcPoly[j5] if j5 >= 0 and j5 < len(self.mSrcPoly) else None).y - (((self.mNormals[j5] if j5 >= 0 and j5 < len(self.mNormals) else None).y * delta)))))
                    _this13 = self.mDestPoly
                    _this13.append(pt1)
                else:
                    j6 = (_hx_len - 1)
                    k2 = (_hx_len - 2)
                    self.mSinA = 0
                    python_internal_ArrayImpl._set(self.mNormals, j6, DoublePoint(-(self.mNormals[j6] if j6 >= 0 and j6 < len(self.mNormals) else None).x,-(self.mNormals[j6] if j6 >= 0 and j6 < len(self.mNormals) else None).y))
                    if (node.mEndtype == EndType.ET_OPEN_SQUARE):
                        self.doSquare(j6,k2)
                    else:
                        self.doRound(j6,k2)
                nj1 = (_hx_len - 1)
                while (nj1 > 0):
                    python_internal_ArrayImpl._set(self.mNormals, nj1, DoublePoint(-python_internal_ArrayImpl._get(self.mNormals, (nj1 - 1)).x,-python_internal_ArrayImpl._get(self.mNormals, (nj1 - 1)).y))
                    nj1 = (nj1 - 1)
                python_internal_ArrayImpl._set(self.mNormals, 0, DoublePoint(-(self.mNormals[1] if 1 < len(self.mNormals) else None).x,-(self.mNormals[1] if 1 < len(self.mNormals) else None).y))
                k2 = (_hx_len - 1)
                nj1 = (k2 - 1)
                while (nj1 > 0):
                    k2 = self.offsetPoint(nj1,k2,node.mJoinType)
                    nj1 = (nj1 - 1)
                if (node.mEndtype == EndType.ET_OPEN_BUTT):
                    pt1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x - (((self.mNormals[0] if 0 < len(self.mNormals) else None).x * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y - (((self.mNormals[0] if 0 < len(self.mNormals) else None).y * delta)))))
                    _this14 = self.mDestPoly
                    _this14.append(pt1)
                    pt1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).x + (((self.mNormals[0] if 0 < len(self.mNormals) else None).x * delta)))),ClipperOffset.round(((self.mSrcPoly[0] if 0 < len(self.mSrcPoly) else None).y + (((self.mNormals[0] if 0 < len(self.mNormals) else None).y * delta)))))
                    _this15 = self.mDestPoly
                    _this15.append(pt1)
                else:
                    k2 = 1
                    self.mSinA = 0
                    if (node.mEndtype == EndType.ET_OPEN_SQUARE):
                        self.doSquare(0,1)
                    else:
                        self.doRound(0,1)
                _this16 = self.mDestPolys
                x15 = self.mDestPoly
                _this16.append(x15)

    def execute(self,solution,delta):
        if Std.isOfType(solution,list):
            self.executePaths(solution,delta)
            return
        elif Std.isOfType(solution,PolyTree):
            self.executePolyTree(solution,delta)
            return
        else:
            raise haxe_Exception.thrown(ClipperException(u"`solution` must be either a Paths or a PolyTree"))

    def executePaths(self,solution,delta):
        _hx_len = len(solution)
        pos = 0
        if (pos < 0):
            pos = (len(solution) + pos)
        if (pos < 0):
            pos = 0
        res = solution[pos:(pos + _hx_len)]
        del solution[pos:(pos + _hx_len)]
        self.fixOrientations()
        self.doOffset(delta)
        clpr = Clipper()
        clpr.addPaths(self.mDestPolys,PolyType.PT_SUBJECT,True)
        if (delta > 0):
            clpr.executePaths(ClipType.CT_UNION,solution,PolyFillType.PFT_POSITIVE,PolyFillType.PFT_POSITIVE)
        else:
            r = hxClipper_ClipperBase.getBounds(self.mDestPolys)
            outer = list()
            x = IntPoint((r.left - 10),(r.bottom + 10))
            outer.append(x)
            x = IntPoint((r.right + 10),(r.bottom + 10))
            outer.append(x)
            x = IntPoint((r.right + 10),(r.top - 10))
            outer.append(x)
            x = IntPoint((r.left - 10),(r.top - 10))
            outer.append(x)
            clpr.addPath(outer,PolyType.PT_SUBJECT,True)
            clpr.reverseSolution = True
            clpr.executePaths(ClipType.CT_UNION,solution,PolyFillType.PFT_NEGATIVE,PolyFillType.PFT_NEGATIVE)
            if (len(solution) > 0):
                if (len(solution) != 0):
                    solution.pop(0)

    def executePolyTree(self,solution,delta):
        solution.clear()
        self.fixOrientations()
        self.doOffset(delta)
        clpr = Clipper()
        clpr.addPaths(self.mDestPolys,PolyType.PT_SUBJECT,True)
        if (delta > 0):
            clpr.executePolyTree(ClipType.CT_UNION,solution,PolyFillType.PFT_POSITIVE,PolyFillType.PFT_POSITIVE)
        else:
            r = hxClipper_ClipperBase.getBounds(self.mDestPolys)
            outer = list()
            x = IntPoint((r.left - 10),(r.bottom + 10))
            outer.append(x)
            x = IntPoint((r.right + 10),(r.bottom + 10))
            outer.append(x)
            x = IntPoint((r.right + 10),(r.top - 10))
            outer.append(x)
            x = IntPoint((r.left - 10),(r.top - 10))
            outer.append(x)
            clpr.addPath(outer,PolyType.PT_SUBJECT,True)
            clpr.reverseSolution = True
            clpr.executePolyTree(ClipType.CT_UNION,solution,PolyFillType.PFT_NEGATIVE,PolyFillType.PFT_NEGATIVE)
            if ((solution.get_numChildren() == 1) and ((python_internal_ArrayImpl._get(solution.get_children(), 0).get_numChildren() > 0))):
                outerNode = python_internal_ArrayImpl._get(solution.get_children(), 0)
                python_internal_ArrayImpl._set(solution.get_children(), 0, python_internal_ArrayImpl._get(outerNode.get_children(), 0))
                python_internal_ArrayImpl._get(solution.get_children(), 0).mParent = solution
                _g = 1
                _g1 = outerNode.get_numChildren()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    solution.addChild(python_internal_ArrayImpl._get(outerNode.get_children(), i))
            else:
                solution.clear()

    def offsetPoint(self,j,k,joinType):
        self.mSinA = (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y) - (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x * (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y)))
        if (Reflect.field(Math,u"fabs")((self.mSinA * self.mDelta)) < 1.0):
            cosA = (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x) + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y * (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y)))
            if (cosA > 0):
                _this = self.mDestPoly
                x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * self.mDelta)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y * self.mDelta)))))
                _this.append(x)
                return k
        elif (self.mSinA > 1.0):
            self.mSinA = 1.0
        elif (self.mSinA < -1.0):
            self.mSinA = -1.0
        if ((self.mSinA * self.mDelta) < 0):
            _this = self.mDestPoly
            x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * self.mDelta)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y * self.mDelta)))))
            _this.append(x)
            _this = self.mDestPoly
            x = (self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None)
            _this.append(x)
            _this = self.mDestPoly
            x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x * self.mDelta)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y * self.mDelta)))))
            _this.append(x)
        else:
            tmp = joinType.index
            if (tmp == 0):
                self.doSquare(j,k)
            elif (tmp == 1):
                self.doRound(j,k)
            elif (tmp == 2):
                r = (1 + ((((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x * (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x) + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y * (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y)))))
                if (r >= self.mMiterLim):
                    self.doMiter(j,k,r)
                else:
                    self.doSquare(j,k)
            else:
                pass
        k = j
        return k

    def doSquare(self,j,k):
        dx = Math.tan((Math.atan2(self.mSinA,(((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x) + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y)))) / 4))
        _this = self.mDestPoly
        x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + ((self.mDelta * (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x - (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y * dx)))))))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + ((self.mDelta * (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * dx)))))))))
        _this.append(x)
        _this = self.mDestPoly
        x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + ((self.mDelta * (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y * dx)))))))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + ((self.mDelta * (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y - (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x * dx)))))))))
        _this.append(x)

    def doMiter(self,j,k,r):
        q = (self.mDelta / r)
        _this = self.mDestPoly
        x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + (((((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x + (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x)) * q)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + (((((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y + (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y)) * q)))))
        _this.append(x)

    def doRound(self,j,k):
        a = Math.atan2(self.mSinA,(((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x) + (((self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y * (self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y))))
        x = ClipperOffset.round((self.mStepsPerRad * Reflect.field(Math,u"fabs")(a)))
        a = None
        try:
            a = int(x)
        except BaseException, _g:
            None
            a = None
        x = (a if (python_lib_Math.isnan(a)) else (1 if (python_lib_Math.isnan(1)) else max(a,1)))
        steps = None
        try:
            steps = int(x)
        except BaseException, _g:
            None
            steps = None
        x = (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).x
        y = (self.mNormals[k] if k >= 0 and k < len(self.mNormals) else None).y
        x2 = None
        _g = 0
        _g1 = steps
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.mDestPoly
            x1 = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + ((x * self.mDelta)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + ((y * self.mDelta)))))
            _this.append(x1)
            x2 = x
            x = ((x * self.mCos) - ((self.mSin * y)))
            y = ((x2 * self.mSin) + ((y * self.mCos)))
        _this = self.mDestPoly
        x = IntPoint(ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).x + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).x * self.mDelta)))),ClipperOffset.round(((self.mSrcPoly[j] if j >= 0 and j < len(self.mSrcPoly) else None).y + (((self.mNormals[j] if j >= 0 and j < len(self.mNormals) else None).y * self.mDelta)))))
        _this.append(x)

    @staticmethod
    def round(value):
        return Clipper.round(value)

    @staticmethod
    def getUnitNormal(pt1,pt2):
        dx = (pt2.x - pt1.x)
        dy = (pt2.y - pt1.y)
        if ((dx == 0) and ((dy == 0))):
            return DoublePoint()
        v = ((dx * dx) + ((dy * dy)))
        f = (1.0 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
        dx = (dx * f)
        dy = (dy * f)
        return DoublePoint(dy,-dx)



class ClipperException(object):
    _hx_class_name = u"ClipperException"
    __slots__ = (u"desc",)
    _hx_fields = [u"desc"]
    _hx_methods = [u"toString"]

    def __init__(self,description):
        self.desc = description

    def toString(self):
        return self.desc



class InternalTools(object):
    _hx_class_name = u"InternalTools"
    __slots__ = ()
    _hx_statics = [u"clear", u"xor"]

    @staticmethod
    def clear(array):
        _hx_len = len(array)
        pos = 0
        if (pos < 0):
            pos = (len(array) + pos)
        if (pos < 0):
            pos = 0
        res = array[pos:(pos + _hx_len)]
        del array[pos:(pos + _hx_len)]

    @staticmethod
    def xor(a,b):
        if (not ((a and (not b)))):
            if b:
                return (not a)
            else:
                return False
        else:
            return True


class hxClipper__Clipper_Ref_Impl_(object):
    _hx_class_name = u"hxClipper._Clipper.Ref_Impl_"
    __slots__ = ()
    _hx_statics = [u"_new", u"get_value", u"set_value", u"__repr__", u"to"]
    value = None

    @staticmethod
    def _new():
        this1 = [None]*1
        this2 = this1
        return this2

    @staticmethod
    def get_value(this1):
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        this1[0] = param
        return param

    @staticmethod
    def __repr__(this1):
        return ((u"@[" + Std.string(this1[0])) + u"]")

    @staticmethod
    def to(v):
        this1 = [None]*1
        this2 = this1
        ret = this2
        ret[0] = v
        return ret


class python_Boot(object):
    _hx_class_name = u"python.Boot"
    __slots__ = ()
    _hx_statics = [u"keywords", u"toString1", u"fields", u"simpleField", u"field", u"getInstanceFields", u"getSuperClass", u"getClassFields", u"prefixLength", u"unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return u"null"
        if isinstance(o,unicode):
            return o
        if (s is None):
            s = u""
        if (len(s) >= 5):
            return u"<...>"
        if isinstance(o,bool):
            if o:
                return u"true"
            else:
                return u"false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return unicode(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return unicode(Math.floor((o + 0.5)))
                else:
                    return unicode(o)
            except BaseException, _g:
                None
                return unicode(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = u"["
            s = ((u"null" if s is None else s) + u"\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = u""
                if (i > 0):
                    prefix = u","
                st = ((u"null" if st is None else st) + HxOverrides.stringOrNull((((u"null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = ((u"null" if st is None else st) + u"]")
            return st
        try:
            if hasattr(o,u"toString"):
                return o.toString()
        except BaseException, _g:
            None
        if hasattr(o,u"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = (((u"" + (u"null" if f is None else f)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),((u"null" if s is None else s) + u"\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = ((u"{ " + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr]))) + u" }")
                except BaseException, _g:
                    None
                    return u"{ ... }"
                if (toStr is None):
                    return u"{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = u""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = u""
                        if (i > 0):
                            prefix = u","
                        paramsStr = ((u"null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull((((u"null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + u"(") + (u"null" if paramsStr is None else paramsStr)) + u")")
                else:
                    return o1.tag
            if hasattr(o,u"_hx_class_name"):
                if (o.__class__.__name__ != u"type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = (((u"" + (u"null" if f is None else f)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),((u"null" if s is None else s) + u"\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr]))) + u" )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = (((u"" + (u"null" if f is None else f)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),((u"null" if s is None else s) + u"\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = ((((u"#" + HxOverrides.stringOrNull(o._hx_class_name)) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr]))) + u" )")
                    return toStr
            if (o == unicode):
                return u"#String"
            if (o == list):
                return u"#Array"
            if callable(o):
                return u"function"
            try:
                if hasattr(o,u"__repr__"):
                    return o.__repr__()
            except BaseException, _g:
                None
            if hasattr(o,u"__str__"):
                return o.__str__([])
            if hasattr(o,u"__name__"):
                return o.__name__
            return u"???"
        else:
            return unicode(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,u"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != u'_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,u"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,unicode):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == u"charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == u"lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == u"toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == u"toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == u"substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == u"split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == u"indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == u"toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == u"charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == u"length"):
                    return len(o)
                elif (field1 == u"substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == u"lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == u"copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == u"join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == u"push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == u"sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == u"shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == u"slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == u"indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == u"reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == u"unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == u"map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == u"pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == u"contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == u"iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == u"toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == u"keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == u"concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == u"filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == u"insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == u"length"):
                    return len(o)
                elif (field1 == u"remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == u"splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,u"_hx_fields")) else [])
        if hasattr(c,u"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,u"_hx_super"):
                return c._hx_super
            return None
        except BaseException, _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,u"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == u"_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_HaxeIterator(object):
    _hx_class_name = u"python.HaxeIterator"
    __slots__ = (u"it", u"x", u"has", u"checked")
    _hx_fields = [u"it", u"x", u"has", u"checked"]
    _hx_methods = [u"next", u"hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.next()
                self.has = True
            except BaseException, _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class python_internal_ArrayImpl(object):
    _hx_class_name = u"python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = [u"concat", u"copy", u"iterator", u"keyValueIterator", u"indexOf", u"lastIndexOf", u"join", u"toString", u"pop", u"push", u"unshift", u"remove", u"contains", u"shift", u"slice", u"sort", u"splice", u"map", u"filter", u"insert", u"reverse", u"_get", u"_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,u'') for x1 in x])

    @staticmethod
    def toString(x):
        return ((u"[" + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in x]))) + u"]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException, _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(imap(f,x))

    @staticmethod
    def filter(x,f):
        return list(ifilter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides(object):
    _hx_class_name = u"HxOverrides"
    __slots__ = ()
    _hx_statics = [u"eq", u"stringOrNull", u"modf", u"mod"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return u"null"
        else:
            return s

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float(u'nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b


class python_internal_MethodClosure(object):
    _hx_class_name = u"python.internal.MethodClosure"
    __slots__ = (u"obj", u"func")
    _hx_fields = [u"obj", u"func"]
    _hx_methods = [u"__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString(object):
    _hx_class_name = u"HxString"
    __slots__ = ()
    _hx_statics = [u"split", u"charCodeAt", u"charAt", u"lastIndexOf", u"toUpperCase", u"toLowerCase", u"indexOf", u"indexOfImpl", u"toString", u"substring", u"substr"]

    @staticmethod
    def split(s,d):
        if (d == u""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return u""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == u""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == u""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return u""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]

Math.NEGATIVE_INFINITY = float(u"-inf")
Math.POSITIVE_INFINITY = float(u"inf")
Math.NaN = float(u"nan")
Math.PI = python_lib_Math.pi

hxClipper_ClipperBase.HORIZONTAL = -3.4E+38
hxClipper_ClipperBase.SKIP = -2
hxClipper_ClipperBase.UNASSIGNED = -1
hxClipper_ClipperBase.TOLERANCE = 1.0E-20
hxClipper_ClipperBase.LO_RANGE = 32767
hxClipper_ClipperBase.HI_RANGE = 32767
ClipperOffset.TWO_PI = 6.283185307179586476925286766559
ClipperOffset.DEFAULT_ARC_TOLERANCE = 0.25
python_Boot.keywords = set([u"and", u"del", u"from", u"not", u"with", u"as", u"elif", u"global", u"or", u"yield", u"assert", u"else", u"if", u"pass", u"None", u"break", u"except", u"import", u"raise", u"True", u"class", u"exec", u"in", u"return", u"False", u"continue", u"finally", u"is", u"try", u"def", u"for", u"lambda", u"while"])
python_Boot.prefixLength = len(u"_hx_")